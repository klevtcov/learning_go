## Композитные типы

В этой теме вы познакомитесь с более сложными типами данных:

* научитесь работать с указателями;
* узнаете, как определять массивы и слайсы;
* изучите ассоциативные массивы и структурные типы данных.


### Указатели

Все данные программы, включая переменные, хранятся в памяти компьютера. Нумерация поддерживает порядок в ячейках, и такие номера называются адресами. Каждая переменная имеет адрес в виде целого положительного числа.
Если нужно передать переменную из одной части программы в другую, хватит обычного копирования:

```
a := 5

var b int
b = a 
```

Значение переменной а полностью скопировалось в b. 

В плане удобства это далеко не универсальный способ. Во-первых, размер переменной a может быть очень большим, копирование займёт много времени. Во-вторых, иногда копии может быть недостаточно и нужно получить саму переменную — к примеру, чтобы изменить её значение. 

```
Тогда на помощь приходят указатели. Если вы знакомы с языком С, то легко разберётесь и с указателями в Go, в то время как программистам на Python придётся вникать в новую тему. 
```

Итак, если у каждой переменной есть адрес, мы можем передавать его, а не сами данные, хранящиеся в ячейке памяти. За хранение значения адреса переменной в Go отвечают указатели. Данные любого типа хранятся в виде двоичных чисел, поэтому для определения конкретного типа данных в ячейке памяти указатель сам имеет соответствующий тип.

Синтаксис переменной типа «указатель» очень простой:

> var p *int 

Здесь создали переменную типа «указатель на целое число». В Go можно создать указатель на любой тип данных.
Физически указатель — это ячейка памяти, хранящая адрес ячейки, на которую «смотрит» указатель. После создания указатель не «смотрит» ни на одну ячейку памяти в компьютере и имеет нулевое значение. Оно выглядит как nil.

Для того чтобы присвоить указателю значение (адрес какой-либо переменной), используется операция взятия адреса &:

```
var a int = 5
p := &a

fmt.Println(a,p) //a=5 p=0xc0000b2008 
```

Значение указателя на 64-битном компьютере — это 64-битное число. Именно размер указателя на данной системе задаёт характеристику битности компьютера.

На разных платформах значение указателя p будет разным. Именно поэтому значение указателя не имеет смысла за пределами программы.

Чтобы получить значение указателя, в памяти должна быть переменная, на которую он «смотрит». Такое значение называется адресуемым (adressable). С константами сложнее — у них забрать адрес не получится.

```
const c = 5
p1 := &"abc" // ошибка компиляции
p2 := &с // ошибка компиляции 
```

Тип переменной, на которую создаётся указатель, должен соответствовать типу указателя.

```
var p *int
  var a int = 5
  var b string = "abc"
  p = &a 
  p = &b // ошибка компиляции 
```

Литералы композитных типов создают в памяти переменную соответствующего типа, поэтому указатель можно создать вот так:

```
type A struct {
    IntField int
}
// Литерал А{} создаёт в памяти переменную типа А. Затем от неё берётся указатель
p := &A{ 
    IntField: 10,
}
```

А ещё в Go есть встроенная функция new(). В качестве параметра ей передаётся тип, а возвращается указатель на новую переменную соответствующего типа.

```
type A struct {
    IntField int
}

p := new(A) //  то же самое, что и &A{} 
```

Указатели ведут себя так же, как и обычные переменные. Их можно копировать, присваивая другим переменным тип указателя, передавать и возвращать в функции, а также создавать указатели уже на них. 

Тип указателя на указатель описывается как **T, например **int.

Чтобы получить или изменить значение, хранящееся по указателю, применяют оператор разыменования (dereference) *.

```
i := 42
p := &i
fmt.Println(*p) // читаем значение переменной i через указатель p
*p = 21         // записываем в переменную i значение 21 через указатель p 
```

Вызов оператора разыменования на nil-указателе приведёт к панике на этапе исполнения кода, и программа откажется работать дальше.

```
var p *int
fmt.Println(*p) // panic: runtime error: invalid memory address or nil pointer dereference
```

