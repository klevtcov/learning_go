## Структуры

Структура в Go представляет собой тип данных с заданным набором атрибутов (полей), использующийся для описания составных объектов. Структура имеет близкие аналоги в других языках программирования:

* C — struct;
* С++ — class, struct;
* Python — class, tuple;
* PHP — class;
* Lua — table.

Посмотрите, как выглядит описание типа Person:

```
type Person struct {
    Name        string
    Email       string
    dateOfBirth time.Time
}
```

Здесь описан тип структуры, отображающий информацию о некотором человеке: его имя, электронную почту, дату рождения. Поля структуры могут быть любого типа, доступного в языке.

Могут быть и указателями на саму структуру. Классический пример — структура данных «дерево»:

```
type Tree struct {
    Value      int
    LeftChild  *Tree
    RightChild *Tree
} 
```


### Инициализация

Существует несколько подходов к созданию экземпляра объекта.

1. **Пустой объект**

```
p := Person{}
// или
var p Person 
```

Все поля структуры при таком подходе принимают значения по умолчанию.

Подход применяют:

* когда экземпляр не требует специальной инициализации и может быть использован дальше по коду;
* когда для инициализации полей нужны дополнительные условия и данные, то есть выставление значений конкретных полей будет следовать ниже по коду.


2. **Неявное указание значений полей**

```
date := time.Date(2000, 12, 1, 0, 0, 0, 0, time.UTC)
p := Person{"Иван", "ivan@yandex.ru", date} 
```

При таком подходе перечисляют значения для всех полей структуры, используя литералы либо значения внешних переменных.

Требования:
* Нужно перечислить все поля объекта.
* Порядок следования аргументов инициализатора должен совпадать с порядком описания полей структуры. Если поставить поле Email на первое место в описании type Person struct, инициализация экземпляра выше будет некорректна (с точки зрения логики, но не компилятора).

Подход применяют:
* когда нужно явно указать значения всех полей объекта;
* когда вы уверены, что спецификация типа не будет меняться часто, иначе придётся вносить правки для каждого инициализатора объекта в коде.


3. **Явное указание значений полей**

> p := Person{Name: "Иван", Email: "ivan@yandex.ru"} 

При таком подходе явно указывают имена полей и их значения.

Особенности:
* этот подход отличается от первого опциональным указанием полей;
* порядок указания полей не важен;
* значения полей, которые не были использованы в инициализаторе (dateOfBirth в примере), примут значения по умолчанию.

Для повышения читабельности кода такую инициализацию часто описывают в несколько строк, что справедливо и для второго подхода:

```
p := Person{
    Name:  "Иван",
    Email: "ivan@yandex.ru",
}
```

***Обратите внимание, что последняя строка в многострочной записи литерала тоже заканчивается запятой. Это делается для того, чтобы можно было вставлять и удалять строки, не заботясь о запятой в конце.***

Подход применяют: 
*почти всегда, так как он лишён ограничений, описанных выше.

На практике обычно применяется явное указание имён, потому что оно снижает количество возможных ошибок. 

Рассмотрим пример, когда в коде, возможно в другом пакете или даже репозитории, объявлена структура Person со следующими полями:

```
type Person struct {
    Name string // Имя
    Age  int    // Возраст
}
```

Структура очень простая, и Go инициализирует её следующим образом:

```
man := Person{"Alex", 30}

fmt.Printf("Man %#v", man) 
```

Затем описание структуры изменяется:

```
type Person struct {
    Name     string // Имя
    NumChild int    // Количество детей 
    Age      int    // Возраст
}
```

Компилятор подсказывает, что для инициализации недостаточно полей, тогда добавляем ещё значение:

```
man := Person{"Alex", 30, 2}

fmt.Printf("Man %#v", man) // И получаем работающую (хоть и неправильно) программу
```

Вполне вероятно, что количество детей у человека особо не влияет на код. Однако нам потребовалось внести правки в наш код из-за внешних изменений.

При использовании явного указания полей проблемы бы не возникли:

```
man := Person{Name: "Alex", Age: 30}
// Будет корректно работать с любыми структурами, включающими эти поля 
```

4. **Конструктор**

Учитывая тонкости при инициализации сложного объекта, разработчики применяют конструкторы.  

В Go нет синтаксиса конструкторов и деструкторов, но часто можно встретить аналог:

```
   func NewPerson(name, email string, dobYear, dobMonth, dobDay int) Person {
       return Person{
           Name:        name,
           Email:       email,
           dateOfBirth: time.Date(dobYear, time.Month(dobMonth), dobDay, 0, 0, 0, 0, time.UTC),
       }
   }
```

Вот некоторые правила, одобренные Go-сообществом:
* имя функции конструктора пишут с префиксом New;
* если конструктор производит валидацию аргументов, функция должна возвращать ошибку последним аргументом.

Можем вернуться к нашему примеру, чтобы добавить проверку корректности email и числовых компонент даты, тогда декларация функции примет вид:

> func NewPerson(name, email string, dobYear, dobMonth, dobDay int) (Person, error) {}

Подход применяют:
* когда нужно производить валидацию аргументов, чтобы построить логически правильный объект;
* когда построение экземпляра объекта требует дополнительных действий, например, подключения к базе данных.

***Пример выше не идеален, так как изменение спецификации Person потребует изменения прототипа конструктора или создания новой версии (скажем, NewPersonWithPhone()). Идиоматичные Go-подходы к созданию объектов рассмотрим в следующих темах.***

<img src="https://pictures.s3.yandex.net/resources/3.4_1638892995.png">


### Доступ к полям

Для доступа к полям структуры используется точка (p.Name):

```
p := NewPerson("Иван", "ivan@yandex.ru", 2000, 12, 1)
fmt.Println(p.Name, p.Email)

p.Name = "Пётр"
fmt.Println(p.Name)

// Иван ivan@yandex.ru
// Пётр
```


### Область видимости

Как вы уже знаете, в Go есть понятия экспортируемых и неэкспортируемых типов. Код разделяется на пакеты, и, чтобы тип, функция или глобальная переменная были доступны в другом пакете, их имена должны начинаться с заглавной буквы. Это же правило работает для полей и методов структуры.

<img src="https://pictures.s3.yandex.net/resources/1.4.export_1638893029.png">

В примере выше Person — экспортируемый тип (публичный). Другие пакеты могут создавать экземпляры этого типа и иметь доступ к публичным полям Name и Email. А поле dateOfBirth — неэкспортируемое (приватное).

***Неэкспортируемый тип можно использовать в другом пакете, если есть соответствующий конструктор типа и экспортируемая функция конструктора. Такой трюк встречается в Go-коде, однако чаще всего для сокрытия реализации используют интерфейсы. О них будет рассказано в соответствующей главе нашего курса.***

Приведём пример экспортирования приватного типа:

```
package foo

// privateFoo — неэкспортируемый тип
type privateFoo struct {
    Value string
}

// NewPrivateFoo — конструктор типа privateFoo
// Функция публичная, то есть может быть вызвана из других пакетов
func NewPrivateFoo() privateFoo {
    return privateFoo{Value: "some data"}
}
```
```
package main

import "github.com/the_greatest_coder/hello_go/foo"

func main() {
    // f := foo.privateFoo{} // ошибка компиляции
    f := foo.NewPrivateFoo()
    fmt.Println(f.Value) // поле Value экспортируемое, то есть его можно использовать
}
```

> some data 


### Теги

У каждого поля структуры может быть набор аннотаций, которые называются тегами (tags):

```
type GetUserRequest struct {
    UserId string `json:"user_id" yaml: "user_id" format:"uuid" example:"2e263a90-b74b-11eb-8529-0242ac130003"`
    IsDeleted *bool `json:"is_deleted,omitempty" yaml:"is_deleted"`
}
```

Теги не влияют на представление или работу с данными напрямую, но могут использоваться пакетами для получения дополнительной информации о конкретном поле.

Набор тегов с их значениями можно представить как набор ключей и значений, где ключи разделяются пробелами, а значения ключей — запятой.

В примере выше встречаются следующие теги:
* json — используется пакетом encoding/json для сериализации/десерилизации структур в JSON;
* yaml — похож на json, но используется внешними библиотеками для работы с форматом YAML;
* format и example — могут быть как подсказкой для разработчика, так и аннотацией для генерации Swagger-описания (к примеру, библиотекой swag).

Применяемые аннотации чаще всего зависят от используемой библиотеки. Возможные ключи и значения стоит искать в документации пакета (в худшем случае — в коде).

Разработчик может вводить свои теги и работать с ними через пакет reflect стандартной библиотеки.

