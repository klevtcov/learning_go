## Модули

В этом уроке вы узнаете:

* что такое модули и почему с ними лучше, чем без них;
* как создать свой первый локальный модуль и запустить программу.


Начнём с подхода, при котором в системе может быть установлена только одна версия пакета, а его положение в файловой системе будет однозначно определено путём импорта. 

У этого подхода есть существенные недостатки:

* Нельзя устанавливать несколько версий одной и той же библиотеки, так как у них будет одинаковый путь импорта и Go не сможет их различить. Без работы с разными версиями библиотеки не обойтись, если на каком-то этапе её развития была нарушена обратная совместимость. Например, наше приложение может работать правильно только с определённой версией пакета, который используют другие приложения. Они могут захотеть что-нибудь изменить в этом пакете, и разрешение таких конфликтов обернётся настоящей катастрофой.
* Нельзя свободно перемещать код по файловой системе. Если целевая директория находится за пределами GOPATH/src, код становится недоступен.

Сейчас такой подход применяется только для стандартных библиотек. 

***Эти и многие другие проблемы (например, невозможность хранить в проекте список его зависимостей, по аналогии с package.json в npm JavaScript или requirements.txt для pip в Python) решают модули. После выхода Go 1.16 модули стали способом разрешения зависимостей по умолчанию.***

По официальной документации, модуль — это коллекция пакетов с общими версионированием и релизным циклом. Модули могут загружаться либо напрямую из систем контроля версий, либо с модульных прокси-серверов. О том, как устанавливать модули из внешних источников, поговорим в следующем уроке.

Проще говоря, это группа пакетов, которые хранятся и обновляются вместе. Даже ваше приложение будет являться модулем. 

Метаинформация о модуле содержится в файле go.mod в корневой директории модуля. Полный список всех директив этого файла можно также найти в документации.

Метаинформация о модуле говорит о том, как он будет собираться, экспортироваться и какие будет использовать внешние зависимости.

В этом уроке разберём несколько базовых директив на примере создания локальных модулей, то есть расположенных в нашей файловой системе. Другие виды модулей рассмотрим в следующем уроке. Пример базируется на Go 1.17, поэтому в других версиях некоторые моменты могут отличаться. 


### Создание модуля

Создадим новую директорию ypmodule:

```
mkdir ypmodule
cd ypmodule 
```

Инициализируем модуль внутри директории стандартной утилитой go mod:

> go mod init ypmodule 

В директории создался файл go.mod, содержащий:
```
module ypmodule

go 1.17 
```

Строка module ypmodule содержит путь импорта модуля — это префикс, относительно которого будут импортироваться все пакеты этого модуля. Например, чтобы импортировать пакет somepackage из модуля ypmodule, надо добавить в код строку:

> import "ypmodule/somepackage" 

Следует отметить, что в большинстве случаев файл go.mod не редактируется вручную, а изменяется с помощью go mod.

В примере путь импорта — это одно слово ypmodule. Но путь может быть и полноценным URL. Например, github.com/someuser/somerepo. Такие пути будут рассмотрены далее.

Строка go 1.17 указывает на версию Go, использованную при создании этого модуля.

Создадим в модуле пакет calc для работы с числами и поместим в него файл math.go с функцией сложения целых чисел.
```
package calc

func AddInts(a, b int) int {
    return a + b
}
```

В примере для модуля calc создана отдельная директория. Но если не предполагается добавлять в модуль больше одного пакета, можно писать код прямо в директории с файлом go.mod.

Чтобы протестировать функциональность модуля, создадим рядом с ypmodule ещё один модуль — main. Файловая структура будет выглядеть так:
```
.
├── main
└── ypmodule
    ├── calc
    │   └── math.go
    └── go.mod 
```

Для создания нового модуля выполним в main команду:

> go mod init main 

Создадим в новом модуле файл main.go, содержащий:
```
package main

import (
    "fmt"

    "ypmodule/calc"
)

func main() {
    fmt.Println(calc.AddInts(1, 2))
}
```

Попробуем запустить функцию main. И получим ошибку:
```
main.go:6:2: package ypmodule/calc is not in GOROOT (/usr/local/go/src/ypmodule/calc)
```

***Дело в том, что в файле main/go.mod не описано, где искать модуль ypmodule. Сначала Go пошёл в GOROOT и не обнаружил его. Затем Go увидел, что ypmodule не похож на URL, поэтому искать этот пакет в сети нет смысла.***

Поскольку сейчас работаем с локальным модулем (то есть его код лежит только на нашей файловой системе), для определения его положения на локальном диске нужно воспользоваться директивой replace. После её добавления файл main/go.mod будет выглядеть так:
```
module main

go 1.17

// директивой replace указываем положение корня 
// модуля ypmodule относительно main/go.mod
replace ypmodule => ../ypmodule  
```

***Так как ypmodule содержит внутри себя другие пакеты и зависимости, их тоже нужно указать. Можно не знать о зависимостях и структуре этого модуля, но инструментарий в Go придёт на помощь. ***

Выполним команду go get ypmodule:
```
go get ypmodule

go get: added ypmodule v0.0.0-00010101000000-000000000000
```

В go.mod появилась строка:

> require ypmodule v0.0.0-00010101000000-000000000000 // indirect 

Она указывает, какую конкретно версию модуля ypmodule будет использовать main при сборке. Комментарий // indirect подсказывает, что сам пакет ypmodule в коде не импортируется, только calc. 

Запустим main ещё раз. Ура, всё заработало! Первые локальные модули успешно нашли друг друга.


### Когда нужно применять модули?

На практике — всегда. Модули дают разработчику очень много возможностей по управлению зависимостями программы. Преимущество модулей станет более понятным через один урок. Не стоит опасаться лишней сложности выполнения, так как почти всю работу по настройке модуля за вас может сделать среда разработки и инструментарий Go.


## Внешние зависимости

Сейчас вы узнаете, как работать с внешними зависимостями в своём проекте и какими критериями руководствоваться при выборе таких зависимостей. 

Внешними зависимостями называются пакеты, не входящие в состав стандартной библиотеки. 

Кроме пакетов, хранящихся в локальной файловой системе, нужно работать с пакетами из внешних источников. Например, вам может понадобиться какой-нибудь фреймворк или специфичный пакет.

В Go есть два способа загрузить пакеты:
* вручную установить утилитой go get (подробную документацию можно найти здесь);
* использовать список зависимостей в go.mod.

Рассмотрим оба варианта, но в дальнейшем будем пользоваться только go.mod, так как в проектах лучше выбирать второй способ. Это позволит хранить описание зависимостей локально и облегчит установку другим разработчикам. 


### Установка пакетов вручную утилитой go get

В случае использования go get установка стороннего пакета выглядит так:

> go get github.com/username/packagename

Утилита go get сходит на https://github.com/username/packagename и скачает требуемый пакет, если он был найден по переданному URL. Если система контроля версий поддерживает несколько протоколов, Go по очереди попробует все. Например, в случае гита он попробует https:// и git+ssh://.

После этого скачанные данные будут помещены в GOPATH/src/username/packagename.


### Установка зависимостей из go.mod

Из прошлого урока вы знаете, что система модулей позволяет явно прописать список зависимостей проекта. Для этого используется директива require. После запуска кода Go автоматически скачает пакеты, перечисленные в блоке require, и закеширует их в директории $GOPATH/pkg/mod. 

Например, если в модуле есть единственная зависимость от библиотеки github.com/stretchr/testify, то go.mod будет иметь вид:
```
module somemodule

go 1.16

require github.com/stretchr/testify v1.7.0
```

Также будет создан специальный файл go.sum, обеспечивающий стопроцентную воспроизводимость запусков. Он содержит хеш-суммы всех модулей и тем самым гарантирует воспроизводимую установку модулей на разных окружениях. Подробнее можно прочитать здесь. 

***Зачастую не нужно вручную прописывать зависимости в go.mod. Go может автоматически обновить список зависимостей в go.mod при запуске программы (имеется в виду вызов go run, go build, go test), если путь импорта библиотеки — это URL до репозитория с кодом и не требуется версия библиотеки, отличная от актуальной.***

Но что делать, если нужна не самая свежая версия библиотеки? В этом случае можно указать в директиве require требуемую версию. В примере это была v1.7.0.


### Версионирование

В Go используется семантическое версионирование (Semantic Versioning, или semver).

Семантическое версионирование — это общепринятый формат нумерации релизов (пакетов, модулей, библиотек и т. д.). Версия пишется в формате vX.Y.Z, где:

* X — мажорная версия (major),
* Y — минорная версия (minor),
* Z — патч-версия (patch).

Например, у пакета с версией v1.2.3 есть мажорная версия 1, минорная 2 и патч-версия 3.

* Патч-версию стоит изменять в случае небольших исправлений в пакете.
* Минорная версия меняется в случае добавления новой функциональности.
* Мажорная версия меняется в случае поломки обратной совместимости с предыдущей версией кода.

Увеличение старшего разряда должно происходить с одновременным обнулением младших разрядов. То есть увеличение мажорной версии обнуляет минорную и патч-версию, а увеличение минорной версии обнуляет только патч-версию.

У семантической версии может быть пререлизный суффикс через дефис. Например, v1.2.3-beta.  

В случае работы с Git версия пакета определяется тегом релиза (подробнее о тегах можно прочитать здесь). Теги — это просто метаданные. Есть два типа тегов — легковесные и аннотированные. Первые просто помечают коммит версией, вторые содержат дополнительно кучу информации — имя автора, дату создания, контрольную сумму и так далее. 

Если требуется увеличить версию пакета до некоторого значения (например, v1.2.3), нужно выполнить следующие команды:
```
git tag v1.2.3
git push --tags 
```


### Подмена зависимостей

Иногда нужно подменить библиотеку в коде её форком (копией), но при этом не менять все пути импорта. Например, в ситуации, когда в библиотеке обнаружен критичный баг, PR отправлен, но нет времени ждать, когда его зальют.

На помощь приходит директива replace. В прошлом уроке её использовали, чтобы определить положение локального модуля в файловой системе. Но эта директива также позволяет заменить один внешний модуль (или определённую его версию) на другой. 

Это можно сделать так:
```
replace (
    golang.org/x/net v1.2.3 => example.com/fork/net v1.4.5
    golang.org/x/net => example.com/fork/net v1.4.5
)
```


### Сохранение зависимостей

Итак, модули позволяют исчерпывающе описать, от каких библиотек зависит пакет, и разработчики получают возможность скачать все требуемые зависимости.

Но что, если код зависит от репозитория, который внезапно был удалён или стал приватным? 

Если надо каждый раз ходить за ним в соответствующие репозитории систем контроля версий, это проблема. Репозиторий может быть недоступен из-за блокировок, либо это может быть локальный репозиторий, к которому нужно подключаться через proxy, либо меинтейнер может просто удалить свой репозиторий по каким-то своим причинам.

Есть два решения: вендоринг и go proxy.


### Вендоринг

Вендоринг — это практика, при которой исходный код зависимостей хранится прямо в модуле.

***В Go завендоренные библиотеки должны храниться в папке vendor рядом с файлом go.mod. Чтобы завендорить все используемые библиотеки, нужно выполнить команду go mod vendor.***

Но у вендоринга есть недостатки:

* Папка vendor не используется по умолчанию, если при запуске программы не выставлен флаг -mod=vendor.
* В случае больших монореп эта папка растёт бесконтрольно, что замедляет клонирование репозитория (а это происходит постоянно при прогонах автотестов и прочего CI/CD).
* Пулл-реквесты, на 99% состоящие из завендоренных файлов, сложно ревьюить.

Большую часть этих проблем можно решить прокси-серверами модулей.


### Прокси-серверы модулей

Прокси-сервер модулей — это выделенный сервер для хранения модулей в скачанном и скомпилированном виде.

Использование прокси-сервера модулей имеет ряд преимуществ:
* Папка vendor больше не нужна. Следовательно, в репозитории нет лишних файлов, на ревью они не будут загрязнять диф.
* Прокси-сервера позволяют сильно ускорить загрузку по сравнению с клиентами систем контроля версий.


### Использование прокси-серверов

Адрес прокси-сервера модулей задаётся переменной окружения GOPROXY. Значение этой переменной — перечисленные через запятую адреса прокси-серверов или специальное значение direct. Например:
```
GOPROXY=https://proxy.golang.org/,direct 
```

При скачивании зависимостей go get идёт по URL из этой переменной и пытается скачать требуемую зависимость. Если ни на одном сервере нет нужной зависимости или было встречено специальное значение direct, то go get отправится прямо в репозиторий соответствующей системы контроля версий.

Прокси-сервер по умолчанию — proxy.golang.org. Этот публичный прокси-сервер поддерживается компанией Google и непрерывно кеширует все скачиваемые через него модули.


### Checksum

В файле go.sum хранится информация для стопроцентной воспроизводимости билдов. Но есть проблема: на момент первого билда нет информации о контрольных суммах модулей, и в этот момент злонамеренный прокси-сервер в состоянии отправить нам модифицированный код. Контрольные суммы — это просто хеши, по которым можно определить, изменилось ли содержимое модуля. 

***Для решения этой проблемы в экосистеме Go есть база данных контрольных сумм модулей — checksum.***

При скачивании нового модуля Go сходит в сконфигурированную базу контрольных сумм и проверит, совпадает ли контрольная сумма скачанного кода с той, что хранится в базе. Если это не так, Go выдаст ошибку и закончит работу.

А если в файле go.sum уже есть контрольная сумма скачиваемого модуля, то checksum использоваться не будет.

Адрес используемой checksum определяется переменной окружения GOSUMDB (по умолчанию — sum.golang.org).

Также можно полностью выключить использование checksum, установив GOSUMDB=off.


### Приватные зависимости

Часто в разрабатываемом коде используются как публичные, так и приватные модули. И нужно, чтобы приватные модули не утекли в публичный прокси-сервер зависимостей. Например, вы разрабатываете модуль для внутренних нужд компании и не хотите передавать код конкурентам. 

Есть несколько вариантов, как этого можно избежать:
* Поднять свой приватный прокси (раз, два, три).
* Установить GOPROXY в значение direct, чтобы всегда ходить в обход прокси-серверов.
* Установить переменную GOPRIVATE. Значение этой переменной равно маске путей импорта модулей (например, GOPRIVATE=*.internal.company.com), для которых не нужно использовать прокси-серверы зависимостей, а нужно ходить напрямую в системы контроля версий.


### Как искать подходящие зависимости

Вот несколько советов о том, как среди множества похожих пакетов выбрать тот, который стоит использовать:
* Чем больше звёзд у проекта, тем лучше.
* Чем больше контрибьюторов, тем меньше вероятность, что проект умрёт.
* Чем дольше не было коммитов, тем больше вероятность, что их уже не будет и баги в либе придётся чинить самим.
* Чем лучше покрытие библиотеки тестами, тем меньше вероятность словить баг в зависимости.
* Если репозиторий фигурирует в известном списке репозиториев, скорее всего ему можно доверять (в случае Go можно обращаться, например, к https://github.com/avelino/awesome-go).
* Чем лучше проект документирован, тем больше вероятность, что не придётся искать ответы на свои вопросы в исходниках.


### Задание 

Есть модуль main, состоящий из одного файла main.go:
```
package main

import (
    "fmt"

    "yourpackage" // ваш пакет
)

func main() {
    if sum := yourpackage.Add(1, 2); sum != 3 {
        panic(fmt.Sprintf("sum expected to be 3; got %d", sum))
    }

    fmt.Println("Well done!")
} 
```

Создайте собственный модуль и используйте его в данном примере вместо yourpackage.

Для выполнения этого задания нужно:
* Опубликовать на GitHub свой модуль, в котором определена функция func Add(a, b int) int.
* Создать файл main/go.mod, где будут прописаны все необходимые зависимости.
* Заменить строчку yourpackage на настоящий путь импорта созданного модуля.

```
// File: mymath/go.mod
module github.com/username/mymath

go 1.16

// File: mymath/addition.go
package mymath

func Add(a, b int) int {
    return a + b
}

// File: main/go.mod
module main

go 1.16

require (
    github.com/username/mymath latest
)

// File: main/main.go
package main

import (
    "fmt"

    "github.com/username/mymath"
)

func main() {
    if sum := mymath.Add(1, 2); sum != 3 {
        panic(fmt.Sprintf("sum expected to be 3; got %d", sum))
    }

    fmt.Println("Well done!")
}
```


### Правила хорошего тона при поддержке собственных модулей

В двух предыдущих уроках вы узнали, что такое модули, и разобрались, как работать с локальными и внешними зависимостями. В этом уроке поговорим о том, как публиковать собственные модули в сети, вписывать их в экосистему Go и делать так, чтобы другим разработчикам было удобно ими пользоваться. 

Заодно кратко расскажем о некоторых стандартных утилитах из мира Go, потому что подробный разбор ждёт вас в платной версии курса «Продвинутый Go-разработчик» во время работы над реальным проектом. 

Начнём с форматирования кода.


### Форматирование кода и gofmt

Код, написанный в одном стиле, удобно и приятно читать. Сравните сами:

Плохо отформатированный код:

```
func Add(a, b ArrInt) ArrInt 

{
length := len(a)
if length-len(b) > 0 
    {
length = len(b) }
c := make(ArrInt, length)

for i := 0; i <length; i++ 
    {
    c[i]=a[i]+b[i]
    }

    return c }
```

Хорошо отформатированный код:
```
func Add(a, b ArrInt) ArrInt {
    length := len(a)
    if length-len(b) > 0 {
        length = len(b)
    }
    c := make(ArrInt, length)
    for i := 0; i < length; i++ {
        c[i] = a[i] + b[i]
    }
    return c
}
```

В разных языках вопрос с форматированием решается по-разному. Например, в Python есть официальный стандарт PEP 8, а в C++ — несколько популярных стилей.

***Go решает этот вопрос необычным образом: весь код должен быть отформатирован стандартной утилитой gofmt или её расширенной версией goimports. Утилита goimports делает то же самое, что и gofmt, но ещё автоматически оптимизирует и сортирует импорты.***

Такая утилита позволяет не запоминать, что нужно использовать при выравнивании кода — табы или пробелы, сколько оставлять пустых строк между двумя соседними функциями и прочие мелочи, с которыми машины справляются гораздо лучше людей. Пользуйтесь ею перед публикацией всех своих пакетов — и другие программисты скажут вам спасибо.

Форматирование — далеко не единственное, что определяет качество кода. Разработчики по невнимательности могут употреблять конструкции вроде a = append(a,) или fmt.Printf("Here must be number %d"). В этом случае могут помочь линтеры.


### Линтеры и go vet

В экосистеме Go наиболее распространённый линтер — vet.

В отличие от форматера кода gofmt, линтер не даёт стопроцентной гарантии правильности своей работы — могут быть ложноположительные и ложноотрицательные срабатывания. Скорее всего, придётся немного поколдовать с настройками, прежде чем линтер начнёт корректно работать в каждом проекте. Манипуляции с настройкой и подключением линтера к системам CI/CD окупят себя, когда вы сэкономите время на этапе код-ревью.


### Документация и godoc

В экосистеме Go есть стандартная утилита для создания документации на основе комментариев в коде — это godoc. Запустите go install golang.org/x/tools/...@latest, чтобы установить все пакеты и утилиты golang.org/x/tools, в том числе godoc.

Документация к любой сущности (функции, структуре, переменной или пакету) — это комментарий, который предшествует декларации этой сущности. Например:
```
// Foo выполняет очень важную роль в проекте — ничего не делает :)
func Foo() {}

// описывает новый тип данных «никнейм» на основе стандартного строкового типа
type nickname string
```

На основе таких комментариев godoc может сгенерировать документацию в формате HTML, man pages и т. д.

Документирование публичного API разрабатываемых пакетов позволяет сторонним разработчикам получить ответы на вопросы относительно функционала без чтения исходников. Документируйте свои пакеты — и жизнь пользователей станет лучше.


### Тестирование кода

Как известно, код без тестов по определению сломан. Поэтому тестирование кода — обязательная часть разработки.

Подробный разбор тестирования запланирован в следующих уроках. Сейчас лишь подчеркнём, что пакетом с хорошим покрытием тестами пользоваться значительно приятнее, чем пакетом, в котором работоспособность кода зависит исключительно от внимательности автора.


### Версионирование без неожиданностей

В предыдущем уроке рассматривалась концепция семантического версионирования и говорилось о том, когда стоит менять версию пакета: патчевую, минорную или мажорную. Этих правил нужно придерживаться, особенно в случае поломки обратной совместимости. Ведь при разработке своего проекта никто не хочет внезапно узнать, что с сегодняшнего дня исчезла какая-нибудь функция, о существовании которой он и не подозревал, но из-за которой развалилась компиляция очень важной библиотеки. 

Чтобы защититься от возмущений со стороны пользователей вашей библиотеки, не забывайте инкрементировать мажорную версию каждый раз, когда ломаете в библиотеке обратную совместимость.

<img src="https://code.s3.yandex.net/go/pics/_gopher_.svg">

