## Мапа – словарь, ассоциативный массив, хеш-таблица 

**Словарь, ассоциативный массив, хеш-таблица** — распространённая в программировании структура данных, которая во многих языках встроена в базовый синтаксис, а в остальных реализована на уровне библиотек.


**Ассоциативный массив** — это набор пар вида «ключ-значение». Ключу можно присвоить значение Map[key] = value, а потом извлечь это значение value = Map[key] по ключу. Ключи уникальны: одному ключу соответствует только одно значение.

<img src="https://pictures.s3.yandex.net/resources/3.3_1638894432.png">

На рисунке приведено сравнение ассоциативного и обычного массивов. Если для обычного массива можно получить значение по индексу, то для ассоциативного значение добывается через ключ.

В простом массиве значение элемента можно получить по целочисленному индексу этого элемента. В ассоциативном массиве индексом элемента может служить не только целое число или порядковый номер, но и, например, строка.

Адрес значения для ключа, как правило, вычисляется хеш-функцией, поэтому такую структуру данных ещё называют **хеш-таблицей (hash table, hash map).**

**Хеш-функция** — это любая функция, которая может однозначно перевести любое переданное значение в некоторое множество ограниченных значений. Удобство применения хеш-функций в том, что из неограниченного множества значений можно получить значения из конечного множества. Их можно использовать, например, для адресов массивов.

В различных языках программирования реализация ассоциативного массива различается:

* С++ — библиотечный класс std::map.
* Python — встроенный тип dict().
* PHP — класс Ds\Map.
* Lua — table.

<img src="https://pictures.s3.yandex.net/resources/3.3.HashTable_1639390352.png">

В Go такой тип данных встроен в базовый синтаксис и называется map. 

Пример кода:

```
m := make(map[string]string)    // создаём map — о применении функции make для создания переменных типа map будет рассказано ниже
m["foo"] = "bar"        // заполняем парами «ключ-значение»
m["ping"] = "pong"        
fmt.Println(m)            // печатаем

// map[foo:bar ping:pong] 
```

Теперь разберём подробнее.


### Объявление map

Декларируется тип map так:

> var m map[KeyType]ValueType 

Ключи должны быть одного типа, значения — тоже. При этом тип ключей может не совпадать с типом значений.

В языке Go map — **ссылочный тип (reference type)**, поэтому одного объявления типа map недостаточно.

К примеру, такой код скомпилируется:

```
var m map[string]string
m["foo"] = "bar" 
```

Но выдаст ошибку во время исполнения (run-time panic):

> panic: assignment to entry in nil map 

Переменные типа map инициализируются с помощью функции make(). 
Встроенная функция make() — универсальный конструктор объектов ссылочного типа. 

```
type MyMap map[string] string

var m1 MyMap
m1 = make(MyMap, 5)

// объект готов
m1["foo"] = "bar" 
```

Тип переменной, которую нужно инициализировать, передаётся функции make() первым параметром. Функция может опционально принимать и другие параметры, характерные для конструируемого типа. В случае map это количество элементов, под которое предварительно требуется выделить память. Нет необходимости указывать точное количество, которое нужно для начального выделения памяти, можно и вообще не передавать этот параметр.

Если впоследствии количество элементов будет расти и перестанет умещаться в выделенной памяти, то выделится дополнительная память. Поскольку выделение памяти и сборка мусора занимают время и требуют дополнительных вычислений, лучше всё же прогнозировать и указывать количество. Дело в том, что при добавлении новых данных в map память выделяется с запасом, а когда этот запас иссякнет, потребуется новое выделение памяти. 

Две переменные ссылочного типа могут указывать на один и тот же объект. Для простых типов это выглядит так:

```
x := 5
y := x
x++
// x станет равен 6
// y останется равен 5
```

А для ссылочных типов — так:

```
MyMap2 := MyMap1
MyMap1["foo"] = "bar"
// в MyMap2 тоже появится пара с ключом foo и значением bar
// если поменяем значение в MyMap2,
MyMap2["foo"] = "bazz"
// то изменится значение и в MyMap1 
```


### Сложный литерал (composite literal)

Вы можете не декларировать тип переменной, например string, а просто задать значение литерально:

> MyString := "Это моя строка"

Компилятор сам назначит переменной тип, сконструирует объект и присвоит значение.

Такая нотация работает и для сложных типов.

Для map composite literal выглядит так:

```
MyMap := map[KeyType]ValueType{key1: value1, key2: value2, ... , keyN: valueN,}
// например
MyStringMap := map[string]string{"first": "первый", "second": "второй",}
```

В данном случае композитный литерал создаёт map без использования функции make и уже с инициализированными парами «ключ-значение».


### Ограничения для типов ключей

Для ключей должны быть определены операторы == и !=, поэтому ключ не может быть функцией, хеш-таблицей или слайсом. 

Если вы попробуете сделать так,

> var MyMap map[[]byte]string 

то получите ошибку компиляции:

> ./prog.go:6:12: invalid map key type []byte 

На тип значений не накладывается никаких ограничений.


### Синтаксис map

Значения для ключей устанавливаются оператором присваивания:

> m[key] = value 

А извлекаются индексным выражением:

```
v, ok = m[k]
v, ok := m[k]
var v, ok = m[k] 
```


