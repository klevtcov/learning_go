### Слайсы

Раз длина массива — это часть его типа, то массивы не подходят для хранения коллекций данных динамического размера. Эту задачу решает другой тип данных, который гораздо чаще используется на практике, — слайс (от англ. slice), или срез. Кроме того, слайс избавит нас от проблемы копирования массивов для присваивания.

Слайс — это последовательность переменной длины, состоящая из элементов одного типа. Тип слайса записывается как тип массива без указания размера. Можно инициализировать переменную типа «слайс» значениями, но, в отличие от массива, переменная без инициализации равна nil.

> var mySlice []int 

Слайс очень похож на list в языке Python, но имеет свои особенности.

Слайс — это обёртка над указателем массива, и в Go слайс используется как структура следующего вида:

* указатель на первый элемент базового массива — ptr;
* длина слайса — len, количество элементов в слайсе;
* ёмкость слайса — cap, количество элементов в массиве.

<img src="https://pictures.s3.yandex.net/resources/basics_go_3.2_1654600417.png">

Параметры слайса len и cap могут быть получены с помощью вызова соответствующих встроенных функций len() и cap(). 

Если просто объявить такую структуру, то она будет равна nil.

Для создания слайса используется встроенная функция make():

```
    mySlice := make([]TypeOfelement, LenOfslice, CapOfSlice)
    mySlice := make([]int, 0) // слайс [], базовый массив []
    mySlice := make([]int, 5) // слайс [0 0 0 0 0], базовый массив [0 0 0 0 0]
    mySlice := make([]int, 5, 10) // слайс [0 0 0 0 0], базовый массив [0 0 0 0 0 0 0 0 0 0] 
```

Аргументы функции make:

1. Тип слайса (пустые квадратные скобки и тип элемента слайса).
2. Длина слайса. Если не передана, то по умолчанию равна нулю.
3. Ёмкость слайса — размер базового массива. Если значение не передано, то по умолчанию равна длине слайса.

Функция make создаёт массив длиной cap и записывает указатель на него в структуру слайса. Также она заполняет поля len и cap в этой структуре и возвращает её в виде переменной типа «слайс».

Даже если len и cap переданы как нулевые, сама структура уже не будет равна nil. Она будет выделена в памяти, и указатель на базовый массив получит значение, отличное от nil.

Если передать в функцию make параметр cap меньше len, то будет вызвана ошибка компиляции или паника во время исполнения.

Слайс может быть создан из композитного литерала так же, как и массив. Единственное отличие — не указываем размер массива:

> s := []int{1, 2, 3}  // [1 2 3] 

Длина и ёмкость слайса будут равны композитному литералу.

Новый слайс может быть создан на основе уже существующего слайса или массива. Для этого используется операция взятия слайса.
Она выполняется с помощью двух скобок с двоеточием [i:j], где i — индекс первого элемента нового слайса, а j — индекс следующего элемента, **не входящего** в новый слайс. 

Допускается не указывать i и j — в таком случае i по умолчанию будет равен 0, j — равен длине массива или слайса.

Таким образом, [:] вернёт слайс всего массива, [:k] — от начала и до k-го элемента, [k:] — от k-го элемента до конца массива.

i и j должны быть неотрицательны и не больше len, причем i меньше или равно j. Если эти условия не будут выполнены, возникнет ошибка компиляции или паника.

Рассмотрим пример с массивом среднесуточных температур из раздела про массивы.

```
    weekTempArr := [7]int{1, 2, 3, 4, 5, 6, 7}
    workDaysSlice := weekTempArr[:5]
    weekendSlice := weekTempArr[5:]
    fromTuesdayToThursDaySlice := weekTempArr[1:4] 
    weekTempSlice := weekTempArr[:]
    
    fmt.Println(workDaysSlice, len(workDaysSlice), cap(workDaysSlice)) // [1 2 3 4 5] 5 7
    fmt.Println(weekendSlice, len(weekendSlice), cap(weekendSlice)) // [6 7] 2 2 
    fmt.Println(fromTuesdayToThursDaySlice, len(fromTuesdayToThursDaySlice), cap(fromTuesdayToThursDaySlice)) // [2 3 4] 3 6 
    fmt.Println(weekTempSlice, len(weekTempSlice), cap(weekTempSlice)) // [1 2 3 4 5 6 7] 7 7
```