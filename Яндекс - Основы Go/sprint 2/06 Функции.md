## Функции

К концу 60-х годов прошлого века программисты успели написать столько кода, что начали путаться и повторяться. Напрашивалось решение, которое было бы проще поддерживать и использовать многократно. Именно тогда нидерландский учёный Эдсгер Вибе Дейкстра придумал «структурное программирование» и опубликовал свои идеи в работе «О вреде оператора goto».

Принцип 4 методологии структурного программирования гласит: «Повторяющиеся фрагменты программы можно оформить в виде подпрограмм (процедур и функций)».

**Функция** — это логически целостный участок кода с одним входом и одним выходом в потоке управления. Этот участок можно использовать многократно, обращаясь к нему по имени.

Смысловая нагрузка у функции в программировании примерно такая же, как у функции в математике. У функции есть название и определение. Ей можно передать значения переменных и получить результат.

Сначала нужно определить функцию:

```
func Cube(x int) int { // декларация функции
    return x * x * x  // тело функции
} 
```

И только затем её можно использовать:
```
result := Cube(5) // вызов функции 
```

### Декларация функции в Go

Декларацию функции часто называют сигнатурой (signature).
```
func MyFunction(arg1 arg1type, arg2 arg2type) resultType {
    // тело функции
} 
```

Здесь: 
* MyFunction — имя функции.
* arg1 arg1type — параметр функции и его тип. Типы параметров должны быть заявлены при декларации, потому что Go — статически типизированный язык.
* resultType — тип возвращаемого значения.

Результат функции тоже можно именовать:
```
func Divide(x int) (half int) {
    half = x / 2
    return // тогда в инструкции return имя можно не указывать
} 
```

***Обратите внимание, что нельзя декларировать функцию внутри другой функции. Это ограничение языка, связанное с особенностями компиляции.***


### Параметры

Аргументы передаются функции путём копирования значения, то есть функции не могут изменять переданные им переменные.

Для примера напишем такой код:
```
func increment(x int) {
    // x — локальная переменная для этой функции
    x++ 
}

func main() {
    n := 5
    // n копируется в переменную x
    increment(n) // значение n не изменится
    fmt.Println(n)
}

// 5
```
Если параметры одного типа, можно сократить код:
```
func Sum(x, y int) int{
    return x + y
} 
```

***В Go есть специальный синтаксис для функций, которые можно вызывать с переменным количеством аргументов (variadic functions). Параметр, принимающий такие аргументы, нужно поставить последним в списке, а перед его типом — многоточие.***

> func Sum(x ...int) int 

Внутри функции этот параметр рассматривается как нумерованная последовательность аргументов (slice).
```
func Sum(x ...int) (res int) {
    for _, v := range x {
        res += v
    }
    return
} 
```

Вызывают такую функцию обычным образом, со списком аргументов через запятую:

> sum := Sum(2, 3, 5, 1, 2, 57) 

Если вызвать эту функцию без аргументов Sum(), параметр x примет значение nil. Тогда цикл не пройдёт ни одной итерации, и функция вернёт 0.


### Возвращаемые значения

Функция необязательно возвращает значение. Она может использоваться исключительно ради побочных эффектов, производимых ею в среде исполнения. Например, fmt.Println().

Также функция может возвращать не одно, а несколько значений разных типов.

> func foo() (int, int, string) 

При вызове такой функции должны быть предоставлены переменные, которым надо все эти значения присвоить.

> x, y, z := foo() 

А если некоторые значения не нужны, можно воспользоваться переменной _.

> _, y, _ := foo() 

В функции, которая возвращает значение, обязательно должна быть инструкция return. 

Список возвращаемых значений имеет тот же синтаксис, что и список параметров. Например, можно написать коротко:

> func foo() (x, y, z int) 

Обратите внимание, что здесь возвращаемые значения имеют имена. В теле функции они могут использоваться как обычные переменные. При входе в функцию они будут инициализированы значениями по умолчанию для данного типа.

Если функция содержит именованные возвращаемые значения, то необязательно указывать список возвращаемых значений оператором return. В таком случае будут возвращены значения переменных, которые они имеют к этому моменту.

Вот функция, которая находит индекс буквы в строке и возвращает вторым аргументом false, если буква не найдена:
```
func Index(st string, a rune) (index int, ok bool) {
    for i, c := range st {
        if c == a {
            return i, true
        }
    }
    return // вернутся значения по умолчанию
} 
```

Если количество и тип возвращаемых функцией значений

>func foo() (int, int) 

в точности соответствуют параметрам другой функции,

>func bar(x int, y int) 

то допускается такой синтаксис вызова:

>bar(foo()) 


### Рекурсивные функции

В Go можно декларировать рекурсивную функцию — вызывающую саму себя.

Вот хрестоматийный пример рекурсивного вычисления n!, факториала числа:
```
func fact(n int) int {
    if n == 0 {    // терминальная ветка — то есть условие выхода из рекурсии
        return 1
    } else {    // рекурсивная ветка 
        return n * fact(n-1)
    }
}
```




