## Особенности языка

Go — это компилируемый язык программирования со строгой статической типизацией, сборщиком мусора и встроенным менеджером пакетов. Он разработан с упором на многопоточное программирование. 





### ООП

Парадигме ООП язык следует лишь частично, оставаясь мультипарадигмальным. Несколько ослабить строгую типизацию призван механизм interface (интерфейс). Он даёт возможность задать ограничения на тип в виде списка методов, которые тот должен реализовывать.

Напомним четыре признака объектно-ориентированного программирования:

* Абстракция — возможность определить характеристики (свойства и методы) объекта, которые полностью описывают его возможности. В Go нет классов, но структуры с методами служат им неплохой заменой.
* Инкапсуляция — возможность скрыть реализацию объекта, предоставив пользователю некую спецификацию (интерфейс) взаимодействия с ним. Go даёт возможность задать область видимости (публичные/приватные) методов структур и позволяет спрятать реализацию.
* Наследование — возможность создания производных от родительского объекта, которые будут расширять или изменять свойства и поведение родителя. К сожалению, Go не реализует в полной мере механизм наследования, но есть встраивание — можно создавать типы на основе существующих.
* Полиморфизм — возможность одному и тому же фрагменту кода работать с разными типами данных. Это происходит, когда объект может вести себя как другой объект. В Go нет полиморфизма в классическом понимании, однако похожие действия можно реализовать с помощью интерфейсов. Интерфейс определяет список методов, которые должен реализовывать тип, чтобы удовлетворять данному интерфейсу. Это ослабляет строгую типизацию и позволяет передавать в параметрах разные типы данных, поддерживающие один и тот же интерфейс.


### Язык Go с точки зрения функционального программирования.

* **Функции высшего порядка** — функции, которые могут в аргументах принимать другие функции и возвращать функции в качестве результата. В Go функции рассматриваются как значения и могут передаваться в другие функции, возвращаясь в виде результата.
* **Замыкания.** Go позволяет определять и использовать функции, которые ссылаются на переменные своей родительской функции.
* **Чистые функции.** В Go можно определять функции, которые зависят только от входящих аргументов и не влияют на глобальное состояние.
* **Рекурсия.** Как и в большинстве языков, в Go можно применять рекурсивные вызовы функций.
* **Ленивые вычисления.** В Go нет поддержки ленивых (отложенных) вычислений.
* **Иммутабельность переменных.** В Go переменные могут изменять своё значение, поэтому иммутабельность (неизменяемость) переменных отсутствует.


Видно, что Go полностью не реализует парадигмы объектно-ориентированного и функционального программирования, но частично это компенсируется похожими возможностями. Поэтому Go считается мультипарадигмальным языком программирования.


### Panic

Также в Go существует механизм паники (panic). Если конструкция выше — типичный способ проверить выполнение той или иной функции, то паника выбрасывается только тогда, когда исполняющий код попадает в нестандартную ситуацию, которую невозможно обработать. 

Одна из самых частых причин паники — разыменовывание nil-указателя или выход за пределы массива. По умолчанию паника будет идти вверх по стеку и завершать все функции, пока не завершит функцию main, а вместе с ней и весь процесс.

Однако её можно поймать и обработать, используя конструкцию defer и встроенную функцию recover.
defer — это ещё одна необычная концепция языка, которая позволяет отложенно выполнять блоки кода: например, чтобы закрывать файлы по завершении работы с ними. Можно рассматривать defer как замену деструкторов/менеджеров контекста в других языках (try_with_resources из Java, with из Python).

```
func foo() {
    // паникуем
    panic("unexpected!")
}
//...
    // выполняется после срабатывания паники
    defer func() {
        if r := recover(); r != nil {
            // обработка паники, в переменной r будет лежать строка "unexpected"
        }
    }()
    // внутри foo срабатывает паника
    foo()
```


### Имеются ли инструменты для тестирования?

Выше упоминалась библиотека testing. В Go принято располагать файлы с unit-тестами непосредственно в пакете, функции которого вы тестируете. Например, если код, который вы хотите покрыть тестами, располагается в файле foo.go, для тестов нужно создать файл foo_test.go:

```
foo/ # пакет foo
    foo.go # файл с тестируемым кодом
    foo_test.go # файл с тестами 
```

Содержимое файла foo.go:

```
package foo

func Foo() string {
    return "bar"
} 
```

В файле foo_test.go реализуем функции определённой сигнатуры:

```
// файл foo_test.go
package foo

import (
    "testing"
)

func TestFooFunc(t *testing.T) {
    expectedFooResult := "bar"
    if actualFooResult := Foo(); actualFooResult != expectedFooResult {
        t.Errorf("expected %s; got: %s", expectedFooResult, actualFooResult)
    }
} 
```

Выполнить их можно, просто вызвав команду go test:

```
PASS
ok      github.com/Yandex-Practicum/go-freetrack/00_intro/testing/foo   0.240s 
```


### Какие элементы многопоточности есть в Go?

Как было сказано раннее, многопоточность в Go реализована согласно модели CSP (Communicating Sequential Processes). При таком подходе программа представляет собой множество одновременно работающих подзадач, которые общаются с помощью каналов связи. Задачами в Go выступают горутины (goroutine), связь организована через каналы (channel). 

Изначально в Go была реализована кооперативная многозадачность: пока код в горутине сам не передаст управление (например, попытавшись выполнить блокирующую операцию), забрать управление у этой горутины невозможно. С версии 1.14 планировщик стал в том числе вытесняющим. Вытесняющий планировщик самостоятельно распределяет процессорное время между горутинами.

**Горутина** — это легковесный поток, который занимает гораздо меньше памяти, чем поток ОС. Среда выполнения Go может выполнять несколько горутин на одном потоке операционной системы и быстро переключаться с выполнения одной горутины на другую благодаря их малому размеру. Вытесняющий планировщик старается равномерно распределять процессорное время между горутинами. 

**Каналы** — это второй ключевой элемент в многопоточности на Go. Каналы не только дают возможность потокам обмениваться данными, но и служат для синхронизации их работы. Одна горутина может записать данные в канал, а другая горутина прочитать их. Кроме этого, стандартная библиотека имеет дополнительные примитивы синхронизации потоков.

