## Интерфейсы


В этой теме вы:

* изучите синтаксис определения и реализации интерфейсов;
* узнаете несколько рекомендаций по использованию интерфейсов.


### Концепция интерфейсов и их реализация

В языке Go интерфейс — это набор методов, которые могут быть реализованы типом. Иными словами, интерфейс — описание того, что может сделать тип. 

Если тип имеет методы, описанные в интерфейсе, то этот тип удовлетворяет интерфейсу.

Синтаксис интерфейса очень простой. Вот пример некоторого интерфейса. Обратите внимание, что интерфейс описываем как тип:

```
type MyInterface interface {
    Method1(int) int
    Method2(a string) string 
    //.... может быть ещё много методов
}
```

В фигурных скобках указывается имя метода, список его аргументов и возвращаемых значений. Названия аргументов могут быть опущены, поэтому достаточно указать тип. Но для лучшего понимания кода их лучше писать: описание метода Create(id int, name string, email string) bool более понятно, чем Create(int, string, string) bool, хотя формально эти методы идентичны.

Интерфейс описывает контракт между различными частями программы. Передавая некоторую переменную в разные части программы, описываем, какие методы ожидаем от этой переменной.

Основное назначение интерфейсов — реализация полиморфизма: с одной стороны, тип может реализовывать несколько интерфейсов в разных контекстах применения, с другой стороны, у нас есть возможность написания алгоритмов, работающих с разными типами данных.

Приведём простой пример. Представим, что у нас есть некоторая структура Person, описывающая человека. В различных областях жизни (и нашей программы) человек может выступать в разных ролях: например, быть студентом, работником, родителем и кем-нибудь ещё. Для конкретной области не имеет значения, кем он является в других. На работе от него ждут работы, в обучении — сдачи домашних работ. Как родитель он может сообщить информацию о детях. А ещё он может сообщать информацию о себе.

Опишем эти отношения в коде:
```
package person

// Person - структура, описывающая человека
type Person struct {
    name string
    homework string
    children []*Person
}

// DoHomework — делает домашнюю работу 
func (p Person) DoHomework() string {
    return p.homework
}

// Children — сообщает информацию о детях
func (p Person) Children() []*Person {
    return p.children
}
 
// Work — выполняет поручения на работе
func (p Person) Work( tasks []string ) string {
    s := p.name + " work:"
    for _,task :=  range tasks {
        s += "\n I do " + task    
    }   
    return s
}

// String — сообщает информацию о себе
func (p Person) String() string {
    return p.name
} 
```

<img src="https://pictures.s3.yandex.net/resources/173821653-602f9dc2-3c5c-42ac-a5e5-c09b9b7cbc1b_1655409675.png">

Естественно, не требуется одновременное наличие этих методов в разных участках программы. Более того, их вызов может нарушить нормальную работу программы.

Для примера опишем другой пакет, представляющий собой место работы:
```
package company

// Worker — интерфейс работника компании 
type Worker interface {
    // всё, что он должен уметь делать, — это работать
    Work(tasks []string) string
}

// Company — структура компании 
type Company struct {
    // personal — сотрудники компании
    // обратите внимание, мы создали слайс сотрудников компании, то есть слайс переменных интерфейсного типа Worker
    personal [] Worker
}

// Hire — наём нового сотрудника
// Сотрудник может быть любого типа: человек, робот или сторожевая собака. Главное, чтобы он умел работать, то есть удовлетворял интерфейсу Worker
// Go ещё на этапе компиляции проверяет, соответствует ли интерфейсу переданная переменная
func (с* Company) Hire( newbie Worker ) {
    с.personal = append(с.personal, newbie) 
}

// Process — работа конкретного сотрудника 
func (с Company) Process ( id int,  tasks []string) (res string) {
    return c.personal[id].Work(tasks)
}
```

***Важно***

***Обратите внимание, что для Person явно не указывается, что он реализует интерфейс Worker. Снова вспоминаем утиную типизацию: если что-то выглядит как утка, плавает как утка и крякает как утка, то это утка.***

В этом и есть суть полиморфизма. company может работать с разными сущностями, единственное требование к которым — уметь работать. Это требование и описывается через интерфейс. 

Теперь соединим эти пакеты вместе.
```
package main

import (
    "company"
    "person"
)

func main() {
    pers := person.Person{}
    comp := company.Company{}
    
    comp.Hire(pers) // мы передаём переменную типа Person в функцию, аргументом которой является переменная Worker! 
}
```

На этапе компиляции компилятор проверяет, можно ли person присвоить переменной типа Worker. Для этого проверяется, что тип Person имеет все методы интерфейса Worker. В нашем случае они есть, всё работает. 

C помощью интерфейсов можно написать код, абстрагированный от внешних модулей: при изменениях в них ничего не нужно переделывать в своём коде, и наоборот. 

Интерфейсы добавляют гибкости и снижают связность кода. Пакеты person и company ничего не знают друг о друге, но могут успешно взаимодействовать. 

Продолжим рассматривать наш пример.

Предположим, что мы решили добавить в нашу программу роботов, которые могут работать так же, как и люди:
```
package robot

import "fmt"

// Robot — тип робота
type Robot struct {
    model       string
    serialId    int
    workCounter int
}

func (r Robot) String() string {
    return fmt.Sprintf("Robot %s serialID %d", r.model, r.serialId)
}

// Work — робот выполняет работы и запоминает количество выполненных задач. Поэтому получатель метода — по указателю
func (r *Robot) Work(tasks []string) string {
    res := fmt.Sprintf("%s work:", r)
    for _, task := range tasks {
        res += "\n I do " + task
    }
    r.workCounter += len(tasks)
    return res
}
```

Так как тип *Robot реализует интерфейс Worker, то можно устроить робота на работу в компанию.

***Важно***

С точки зрения Go типы Robot и *Robot (указатель) — разные. В примере метод Work привязан именно к *Robot. Так как формально тип Robot не реализует интерфейс Worker, такой код не скомпилируется:

```
comp := company.Company{}

robo := Robot{};
comp.Hire(robo); 
```

Поэтому будем использовать указатель на робота. Действительно, в этом есть логика. Раз работа в компании изменяет внутреннее состояние робота, то нужно передать указатель именно на неё.
```
comp := company.Company{}

robo := &Robot{};
comp.Hire(robo); 
```

Такой код скомпилируется нормально. Обратите внимание, что в самой компании ничего не пришлось менять. Мы просто создали роботов, которые удовлетворяют всем её требованиям к сотрудникам. Если бы компания работала со структурами, то нам бы пришлось создавать отдельные методы работы в ней с роботами и с людьми. 


### Интерфейсы и код внешних библиотек

Теперь, когда вы знаете синтаксис описания и реализации интерфейсов, рассмотрим практики их использования.

Раз в Go не нужно явно указывать, что тип реализует интерфейс, можно писать свои интерфейсы и к библиотечному коду.

Допустим, вы пользуетесь готовой библиотекой, которая посылает сетевые запросы к API:

```
type BigAPIClient struct {
    // пропустим код
}

func (c *BigAPIClient) Connect() error {
    // ...
}

func (c *BigAPIClient) Close() error {
    // ...
}

func (c *BigAPIClient) FetchMessages() ([]Message, error) {
    // ...
}

func (c *BigAPIClient) SendMessage(email string, message string) error {
    // ...
}

func (c *BigAPIClient) SendStatus(status string) error {
    // ...
}
```

Допустим, вашему коду хватит двух методов. Если вы хотите протестировать интеграцию с этой библиотекой, вам в ней ничего не нужно исправлять. В Go можно легко заменить вызовы методов типа на вызовы методов интерфейса:

```
type Client interface {
    FetchMessages() ([]Message, error)
    SendMessage(email string, message string) error
}

func MyFunc(client Client) {
    // в параметрах вместо типа *BigAPIClient принимаем интерфейс Client
    // код функции и вызывающий код остаются без изменений

    messages, err := client.FetchMessages() 
    if err != nil {
        // ...
    }

    // ...
}

func main() {
    client := &BigAPIClient{}
    MyFunc(client)
}
```

Напишем тестовую заглушку, чтобы протестировать интеграцию.

```
type MockClient struct {
}

func (c *MockClient) FetchMessages() ([]Message, error) {
    return []Message{{Text: "привет"}, {Text: "тестовый пример"}}, nil
}

func (c *MockClient) SendMessage(email string, message string) error {
    // ...
}
```

Теперь функция одинаково работает как c библиотечными методами, так и с подменёнными тестовыми методами:

```
func main() {
    realClient := &BigAPIClient{}
    MyFunc(realClient)

    mockClient := &MockClient{}
    MyFunc(mockClient)
}
```

***Важно***

```
В коде библиотек можно встретить такую конструкцию:

var _ Client = (*MockClient)(nil) 

Эта строчка добавляет явную проверку — реализует ли тип MockClient интерфейс Client. Если данный тип не соответствует спецификации интерфейса, код не скомпилируется. Такая конструкция позволяет сделать проверку до того, как появится код, использующий этот тип.
```


### Интерфейсы должны быть компактными

В Go принято делать интерфейсы по возможности маленькими. Чем проще интерфейс, тем легче воспринимать код. Если в интерфейсе больше 5–10 методов, значит, пора его делить.

Хорошая практика — объявлять интерфейс даже с одним методом. Часто такие интерфейсы называют по имени метода и добавляют суффикс -er.

```
type Stringer interface {
    String() string
}
```


### Композиция интерфейсов

В описании интерфейса можно не только перечислять методы, но и встраивать уже существующие интерфейсы — их можно комбинировать:
```
type Reader interface {
    Read(p []byte) (n int, err error)
}

type Writer interface {
    Write(p []byte) (n int, err error)
}

type FileHandle interface {
    Reader
    Writer
    Close() error
}
```

В итоге интерфейс FileHandle будет содержать три метода: Read, Write и Close.

Композиция интерфейсов — очень важная и удобная в применении вещь. Она позволяет встроить в интерфейс требования другого интерфейса, включая интерфейсы из других пакетов. Например, если компания планирует отправлять всех своих сотрудников на обучение, то она может просто встроить интерфейс Student в интерфейс Worker.  Компания может не знать, какие требования задаёт интерфейс Student, но перекладывает ответственность за это на сотрудников.


### Ключевые мысли
* Интерфейс — это тип языка Go, который описывает не структуру переменной, а её поведение.
* Реализация интерфейса — это создание такого типа, который реализует поведение, описанное интерфейсом.
* Переменной типа интерфейс может быть присвоен объект любого типа, если он удовлетворяет этому интерфейсу.
* С точки зрения языка типы T и *T — разные.
* Интерфейс описывается в том же пакете, в котором применяется, и является частью его контракта для внешних пакетов, которые его реализуют.
* Интерфейсы позволяют снизить связность кода.
* Интерфейсы позволяют реализовать полиморфизм и сокрытие в парадигме ООП.
* Интерфейсы можно комбинировать.
* Можно писать свои интерфейсы и к библиотечному коду.


## Интерфейсы в стандартной библиотеке

В предыдущем уроке вы познакомились с интерфейсами в Go. Среди них были Stringer, Reader и Writer, уже находящиеся в стандартной библиотеке, поэтому в продакшен-код их достаточно импортировать, чтобы не писать с нуля. О других популярных интерфейсах из стандартной библиотеки расскажем ниже.

### fmt.Stringer

```
type Stringer interface {
    String() string
}
```

Этот интерфейс часто используется, когда нужно одной строчкой залогировать сложный объект. Определение интерфейса лежит в пакете fmt.

Для примера возьмём структуру User и допишем к ней реализацию интерфейса fmt.Stringer:

```
type User struct {
    Email        string
    PasswordHash string
    LastAccess   time.Time
}

func (u User) String() string {
    return "user with email " + u.Email
}

func main() {
    u := User{Email: "example@yandex.ru"}
    fmt.Printf("Hello, %s", u)
}

// Hello, user with email example@yandex.ru 
```

Функция fmt.Printf использовала реализацию интерфейса. 


### Пакет io

Пакет io предназначен для реализации средств ввода-вывода, однако в нём есть несколько удобных интерфейсов, которые применяются и для других целей.

### io.Reader

```
type Reader interface {
    Read(p []byte) (n int, err error)
}
```

Этот интерфейс описывает чтение из любого потока данных: сети, файловой системы или буфера. Определение интерфейса лежит в пакете io.

Метод Read считывает в переданный слайс байт данные из источника. В качестве источника могут выступать любые данные, которые описаны в типе. То есть считываем их структуры и записываем в байты. Количество считанных байт неявно задаётся размером буфера — длиной слайса. 

Объясним возможности интерфейса на примере. Есть буфер — и нужно прочитать байты из него. В пакете strings лежит функция strings.NewReader, которая оборачивает обычную строку в структуру strings.Reader. Эта структура имеет метод Read, значит, она реализует интерфейс io.Reader:

```
s := `Hodor. Hodor hodor, hodor. Hodor hodor hodor hodor hodor. Hodor. Hodor! 
Hodor hodor, hodor; hodor hodor hodor. Hodor. Hodor hodor; hodor hodor - hodor, 
hodor, hodor hodor. Hodor, hodor. Hodor. Hodor, hodor hodor hodor; hodor hodor; 
hodor hodor hodor! Hodor hodor HODOR! Hodor hodor... Hodor hodor hodor...`

// обернём строчку в strings.Reader
r := strings.NewReader(s)

// создадим буфер на 16 байт
b := make([]byte, 16)

for {
    // strings.Reader скопирует 16 байт в b
    //
    // в структуре запоминается последний указатель,  
    // то есть следующий вызов скопирует следующую порцию из 16 байт
    //
    // также метод возвращает количество прочитанных байт n и ошибку err
    //
    // когда дойдём до конца строки, метод отдаст ошибку io.EOF
    n, err := r.Read(b)

    // при работе с интерфейсом io.Reader нужно в первую очередь проверять
    // n > 0, затем err != nil
    //
    // могут быть ситуации, когда часть данных получилось прочитать
    // и сохранить в буфер, а затем произошла ошибка 
    //
    // в таком случае будут одновременно n > 0 и err != nil
    if n > 0 {
        // выведем на экран содержимое буфера
        fmt.Printf("%v\n", b)
    }

    if err != nil {
        // если дочитали до конца, выходим из цикла
        if errors.Is(err, io.EOF) {
            break
        }

        // обрабатываем ошибку чтения
        fmt.Printf("error: %v\n", err)
    }
}
```

Удобство применения io.Reader в том, что его пользователь может вообще не знать, откуда берутся данные: из файла, сети или генерируются на лету. Интерфейс описывает унифицированный метод работы с ними.

Для закрепления реализуем генератор случайных данных:

```
package randbyte

import (
    "io"
    "math/rand"
)

type generator struct {
    rnd rand.Source // Генератор случайных чисел. Вообще rand.Rand уже реализует интерфейс io.Reader, но для примера мы реализуем его самостоятельно.
}

// New — обратите внимание, что мы возвращаем generator, присвоенный интерфейсу io.Reader, сама структура generator неэкспортируемая.
// Мы скрыли внутри пакета все детали.
func New(seed int64) io.Reader {
    return &generator{
        rnd: rand.NewSource(seed),
    }
}

// Read — реализация io.Reader
func (g *generator) Read(bytes []byte) (n int, err error) { // error — это тип ошибки, подробнее мы рассмотрим его в следующем разделе.
    for i := range bytes {
        randInt := g.rnd.Int63()  // функция возвращает положительное число в пределах от 0 до 2^63
        randByte := byte(randInt) // приводим к типу byte
        bytes[i] = randByte
    }
    return len(bytes), nil
}
```
```
package main

import (
    "example/randbyte"
    "fmt"
    "time"
)

func main() {

    // создаём генератор случайных чисел
    generator := randbyte.New(time.Now().UnixNano()) // в качестве затравки передаём ему текущее время, и при каждом запуске оно будет разным.

    buf := make([]byte, 16)

    for i := 0; i < 5; i++ {
        n, _ := generator.Read(buf) // единственный доступный метод, но он нам и нужен.
        fmt.Printf("Generate bytes: %v size(%d)\n", buf, n)
    }

}
```
Мы реализовали простой генератор случайных байт. 

В последнем рассмотренном примере реализация функции Read не очень эффективна — генератор случайных чисел возвращает 64-битное число, то есть 8 байт. Из них используем только 1.

Попробуйте реализовать более эффективное решение. Для упрощения примера считайте, что функция будет принимать только слайсы, длина которых кратна 8. Для преобразования числа в слайс байт можно использовать функцию из стандартной библиотеки binary.LittleEndian.PutUint64([ ]byte, uint64).

```
// Read — реализация io.Reader
func (g *generator) Read(bytes []byte) (n int, err error) { // error это тип ошибки, подробнее мы рассмотрим его в следующем разделе.
    for i := 0; i+8 < len(bytes); i += 8 {
        binary.LittleEndian.PutUint64(bytes[i:i+8], uint64(g.rnd.Int63()))
    }
    return len(bytes), nil
}
```


### io.Writer

```
type Writer interface {
    Write(p []byte) (n int, err error)
} 
```

Этот интерфейс означает запись в любой возможный поток данных: сетевой сокет, файл или буфер. Определение интерфейса лежит в пакете io.

C этим интерфейсом ситуация, обратная io.Reader. Он позволяет записать переданный ему слайс байт куда-то. Куда именно — определяется реализацией.

Для примера соберём большую строку из подстрок, вот только не через оператор +=, потому что тогда на каждую итерацию будет лишняя копия всей строки. В пакете strings есть структура strings.Builder для сборки строки без избыточного копирования. Эта структура имеет метод Write, значит, она реализует интерфейс io.Writer:

```
// создаём strings.Builder
w := strings.Builder{}

for i := 0; i < 50; i++ {
    // функция fmt.Fprintf принимает аргументом io.Writer
    // благодаря этому можно записывать форматированный вывод
    fmt.Fprintf(&w, "%v", math.NaN())
}

w.Write([]byte("... BATMAN!"))

// выводим собранную строку
fmt.Printf("%s\n", &w)
```

Приведём пример реализации интерфейса Write. Предположим, что мы хотим посчитать хеш от некоторого массива байт или наборов массивов. Для простоты возьмём упрощённую функцию хеширования:
```
package hashbyte

import "io"

type Hasher interface {
    io.Writer // мы встроили интерфейс io.Writer в наш интерфейс, чтобы задать требование по наличию метода Write
    Hash() byte
}

type hash struct {
    result byte
}

func New(_init byte) Hasher {
    return &hash{
        result: _init,
    }
}

// Write — сюда может быть записан массив байт любой длины, для которой будет подсчитываться хэш.
func (h *hash) Write(bytes []byte) (n int, err error) {
    // обновляем хеш для каждого байта, записанного в хешер
    for _, b := range bytes {
        h.result = (h.result^b)<<1 + b%2 
    }
    return len(bytes), nil
}

func (h hash) Hash() byte {
    return h.result
}
```

Теперь используем её в нашей программе: 
```
func main() {

    // создаём генератор случайных чисел
    generator := randbyte.New(time.Now().UnixNano()) // в качестве затравки передаём ему текущее время — при каждом запуске оно будет разным

    buf := make([]byte, 16)

    for i := 0; i < 5; i++ {
        n, _ := generator.Read(buf)
        fmt.Printf("Generate bytes: %v size(%d)\n", buf, n)
    }

    hasher := hashbyte.New(0)
    hasher.Write(buf)
    fmt.Printf("Hash: %v \n", hasher.Hash())

}
```


### Функции-утилиты для io.Reader и io.Writer

### io.Copy

> func Copy(dst Writer, src Reader) (written int64, err error)

Функция копирует все байты из io.Reader в io.Writer.

Данные будут считываться до тех пор, пока функция Read не вернёт вторым аргументом ошибку. Если в качестве ошибки будет возвращено значение io.EOF, то выполнение функции закончится без ошибок. Также будет возвращено количество байт. 

io.EOF происходит от end of frame (конец файла) — исторически так назывался специальный символ, который означал конец файла. 

Приведём простой пример. Напишем функцию, копирующую содержимое одного файла в другой:

```

func CopyFile(srcFileName, dstFileName string) error {
    srcFile, err := os.Open(srcFileName)
    if err != nil {
        return err
    }
    dstFile, err := os.Create(dstFileName)
    if err != nil {
        return err
    }
    n, err := io.Copy(dstFile, srcFile)
    if err != nil {
        return err
    }
    fmt.Printf("Copied %d bytes from %s to %s", n, srcFileName, dstFileName)
    return nil
}
```

Структура типа os.File реализует интерфейсы io.Reader и io.Writer. 

Было бы просто считать весь исходный файл в память и затем скопировать его в новый. Но если исходный файл занимает сотни гигабайт? io.Copy работает умнее, считывая и записывая данные небольшими кусочками, поэтому для подобных операций рекомендуется использовать именно её.


### io.CopyN

> func CopyN(dst Writer, src Reader, n int64) (written int64, err error) 

Функция копирует все байты из io.Reader в io.Writer, но не более n байт. То же самое, что и Copy, но с ограничением — можно использовать с источниками данных, которые слишком большие или вообще бесконечные. Например, напишем функцию, которая будет сохранять данные из нашего генератора случайных чисел в файл.

```
// Dump — сохраняет вычисленные данные в файл
func (g generator) Dump(n int64, dst *os.File) error {
    _, err := io.CopyN(g, dst, n)
    return err
}
```

Если бы мы использовали Copy, то программа продолжила бы работать до переполнения диска. 


### io.ReadAll

> func ReadAll(r Reader) ([]byte, error) 

Функция считывает все байты из io.Reader. Чтение закончится, когда io.Reader вернёт io.EOF. 


### io.ReadAtLeast

> func ReadAtLeast(r Reader, buf []byte, min int) (n int, err error) 

Функция считывает байты из io.Reader c ограничением: если прочитанных байт оказалось меньше, чем n, вернётся ошибка io.ErrUnexpectedEOF. Это используется при парсинге бинарных данных, чтобы гарантировать, что нужное минимальное количество байт будет вычитано.


### Другие интерфейсы пакета io

Мы привели примеры основных методов работы с функциями и интерфейсами ввода-вывода. Кроме них, в пакете осталось ещё много интересного. Рекомендуем открыть документацию пакета io, чтобы посмотреть на определения остальных интерфейсов. io.Reader и io.Writer — основные интерфейсы, но могут пригодиться и другие.


В пакете io есть функция LimitReader(r io.Reader, n int64) io.Reader. Она ограничивает количество байт, которое можно вычитать из io.Reader. 
```
package main

import (
    "io"
    "log"
    "os"
    "strings"
)

type LimitedReader struct {
    reader io.Reader
    //  запоминаем количество считанных байт
    left   int
}

func LimitReader(r io.Reader, n int) io.Reader {
    return &LimitedReader{reader: r, left: n}
}

func (r *LimitedReader) Read(p []byte) (int, error) {
    if r.left == 0 {
        return 0, io.EOF
    }
    if r.left < len(p) {
        p = p[0:r.left]
    }
    n, err := r.reader.Read(p)
    r.left -= n
    return n, err
}

func main() {
    r := strings.NewReader("some io.Reader stream to be read\n")
    lr := LimitReader(r, 4)

    _, err := io.Copy(os.Stdout, lr)
    if err != nil {
        log.Fatal(err)
    }
}
```


