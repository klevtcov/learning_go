## Интерфейсы


В этой теме вы:

* изучите синтаксис определения и реализации интерфейсов;
* узнаете несколько рекомендаций по использованию интерфейсов.


### Концепция интерфейсов и их реализация

В языке Go интерфейс — это набор методов, которые могут быть реализованы типом. Иными словами, интерфейс — описание того, что может сделать тип. 

Если тип имеет методы, описанные в интерфейсе, то этот тип удовлетворяет интерфейсу.

Синтаксис интерфейса очень простой. Вот пример некоторого интерфейса. Обратите внимание, что интерфейс описываем как тип:

```
type MyInterface interface {
    Method1(int) int
    Method2(a string) string 
    //.... может быть ещё много методов
}
```

В фигурных скобках указывается имя метода, список его аргументов и возвращаемых значений. Названия аргументов могут быть опущены, поэтому достаточно указать тип. Но для лучшего понимания кода их лучше писать: описание метода Create(id int, name string, email string) bool более понятно, чем Create(int, string, string) bool, хотя формально эти методы идентичны.

Интерфейс описывает контракт между различными частями программы. Передавая некоторую переменную в разные части программы, описываем, какие методы ожидаем от этой переменной.

Основное назначение интерфейсов — реализация полиморфизма: с одной стороны, тип может реализовывать несколько интерфейсов в разных контекстах применения, с другой стороны, у нас есть возможность написания алгоритмов, работающих с разными типами данных.

Приведём простой пример. Представим, что у нас есть некоторая структура Person, описывающая человека. В различных областях жизни (и нашей программы) человек может выступать в разных ролях: например, быть студентом, работником, родителем и кем-нибудь ещё. Для конкретной области не имеет значения, кем он является в других. На работе от него ждут работы, в обучении — сдачи домашних работ. Как родитель он может сообщить информацию о детях. А ещё он может сообщать информацию о себе.

Опишем эти отношения в коде:
```
package person

// Person - структура, описывающая человека
type Person struct {
    name string
    homework string
    children []*Person
}

// DoHomework — делает домашнюю работу 
func (p Person) DoHomework() string {
    return p.homework
}

// Children — сообщает информацию о детях
func (p Person) Children() []*Person {
    return p.children
}
 
// Work — выполняет поручения на работе
func (p Person) Work( tasks []string ) string {
    s := p.name + " work:"
    for _,task :=  range tasks {
        s += "\n I do " + task    
    }   
    return s
}

// String — сообщает информацию о себе
func (p Person) String() string {
    return p.name
} 
```

<img src="https://pictures.s3.yandex.net/resources/173821653-602f9dc2-3c5c-42ac-a5e5-c09b9b7cbc1b_1655409675.png">

Естественно, не требуется одновременное наличие этих методов в разных участках программы. Более того, их вызов может нарушить нормальную работу программы.

Для примера опишем другой пакет, представляющий собой место работы:
```
package company

// Worker — интерфейс работника компании 
type Worker interface {
    // всё, что он должен уметь делать, — это работать
    Work(tasks []string) string
}

// Company — структура компании 
type Company struct {
    // personal — сотрудники компании
    // обратите внимание, мы создали слайс сотрудников компании, то есть слайс переменных интерфейсного типа Worker
    personal [] Worker
}

// Hire — наём нового сотрудника
// Сотрудник может быть любого типа: человек, робот или сторожевая собака. Главное, чтобы он умел работать, то есть удовлетворял интерфейсу Worker
// Go ещё на этапе компиляции проверяет, соответствует ли интерфейсу переданная переменная
func (с* Company) Hire( newbie Worker ) {
    с.personal = append(с.personal, newbie) 
}

// Process — работа конкретного сотрудника 
func (с Company) Process ( id int,  tasks []string) (res string) {
    return c.personal[id].Work(tasks)
}
```

***Важно***

***Обратите внимание, что для Person явно не указывается, что он реализует интерфейс Worker. Снова вспоминаем утиную типизацию: если что-то выглядит как утка, плавает как утка и крякает как утка, то это утка.***

В этом и есть суть полиморфизма. company может работать с разными сущностями, единственное требование к которым — уметь работать. Это требование и описывается через интерфейс. 

Теперь соединим эти пакеты вместе.
```
package main

import (
    "company"
    "person"
)

func main() {
    pers := person.Person{}
    comp := company.Company{}
    
    comp.Hire(pers) // мы передаём переменную типа Person в функцию, аргументом которой является переменная Worker! 
}
```

На этапе компиляции компилятор проверяет, можно ли person присвоить переменной типа Worker. Для этого проверяется, что тип Person имеет все методы интерфейса Worker. В нашем случае они есть, всё работает. 

C помощью интерфейсов можно написать код, абстрагированный от внешних модулей: при изменениях в них ничего не нужно переделывать в своём коде, и наоборот. 

Интерфейсы добавляют гибкости и снижают связность кода. Пакеты person и company ничего не знают друг о друге, но могут успешно взаимодействовать. 

Продолжим рассматривать наш пример.

Предположим, что мы решили добавить в нашу программу роботов, которые могут работать так же, как и люди:
```
package robot

import "fmt"

// Robot — тип робота
type Robot struct {
    model       string
    serialId    int
    workCounter int
}

func (r Robot) String() string {
    return fmt.Sprintf("Robot %s serialID %d", r.model, r.serialId)
}

// Work — робот выполняет работы и запоминает количество выполненных задач. Поэтому получатель метода — по указателю
func (r *Robot) Work(tasks []string) string {
    res := fmt.Sprintf("%s work:", r)
    for _, task := range tasks {
        res += "\n I do " + task
    }
    r.workCounter += len(tasks)
    return res
}
```

Так как тип *Robot реализует интерфейс Worker, то можно устроить робота на работу в компанию.

***Важно***

С точки зрения Go типы Robot и *Robot (указатель) — разные. В примере метод Work привязан именно к *Robot. Так как формально тип Robot не реализует интерфейс Worker, такой код не скомпилируется:

```
comp := company.Company{}

robo := Robot{};
comp.Hire(robo); 
```

Поэтому будем использовать указатель на робота. Действительно, в этом есть логика. Раз работа в компании изменяет внутреннее состояние робота, то нужно передать указатель именно на неё.
```
comp := company.Company{}

robo := &Robot{};
comp.Hire(robo); 
```

Такой код скомпилируется нормально. Обратите внимание, что в самой компании ничего не пришлось менять. Мы просто создали роботов, которые удовлетворяют всем её требованиям к сотрудникам. Если бы компания работала со структурами, то нам бы пришлось создавать отдельные методы работы в ней с роботами и с людьми. 


### Интерфейсы и код внешних библиотек

Теперь, когда вы знаете синтаксис описания и реализации интерфейсов, рассмотрим практики их использования.

Раз в Go не нужно явно указывать, что тип реализует интерфейс, можно писать свои интерфейсы и к библиотечному коду.

Допустим, вы пользуетесь готовой библиотекой, которая посылает сетевые запросы к API:

```
type BigAPIClient struct {
    // пропустим код
}

func (c *BigAPIClient) Connect() error {
    // ...
}

func (c *BigAPIClient) Close() error {
    // ...
}

func (c *BigAPIClient) FetchMessages() ([]Message, error) {
    // ...
}

func (c *BigAPIClient) SendMessage(email string, message string) error {
    // ...
}

func (c *BigAPIClient) SendStatus(status string) error {
    // ...
}
```

Допустим, вашему коду хватит двух методов. Если вы хотите протестировать интеграцию с этой библиотекой, вам в ней ничего не нужно исправлять. В Go можно легко заменить вызовы методов типа на вызовы методов интерфейса:

```
type Client interface {
    FetchMessages() ([]Message, error)
    SendMessage(email string, message string) error
}

func MyFunc(client Client) {
    // в параметрах вместо типа *BigAPIClient принимаем интерфейс Client
    // код функции и вызывающий код остаются без изменений

    messages, err := client.FetchMessages() 
    if err != nil {
        // ...
    }

    // ...
}

func main() {
    client := &BigAPIClient{}
    MyFunc(client)
}
```

Напишем тестовую заглушку, чтобы протестировать интеграцию.

```
type MockClient struct {
}

func (c *MockClient) FetchMessages() ([]Message, error) {
    return []Message{{Text: "привет"}, {Text: "тестовый пример"}}, nil
}

func (c *MockClient) SendMessage(email string, message string) error {
    // ...
}
```

Теперь функция одинаково работает как c библиотечными методами, так и с подменёнными тестовыми методами:

```
func main() {
    realClient := &BigAPIClient{}
    MyFunc(realClient)

    mockClient := &MockClient{}
    MyFunc(mockClient)
}
```

***Важно***

```
В коде библиотек можно встретить такую конструкцию:

var _ Client = (*MockClient)(nil) 

Эта строчка добавляет явную проверку — реализует ли тип MockClient интерфейс Client. Если данный тип не соответствует спецификации интерфейса, код не скомпилируется. Такая конструкция позволяет сделать проверку до того, как появится код, использующий этот тип.
```


### Интерфейсы должны быть компактными

В Go принято делать интерфейсы по возможности маленькими. Чем проще интерфейс, тем легче воспринимать код. Если в интерфейсе больше 5–10 методов, значит, пора его делить.

Хорошая практика — объявлять интерфейс даже с одним методом. Часто такие интерфейсы называют по имени метода и добавляют суффикс -er.

```
type Stringer interface {
    String() string
}
```


### Композиция интерфейсов

В описании интерфейса можно не только перечислять методы, но и встраивать уже существующие интерфейсы — их можно комбинировать:
```
type Reader interface {
    Read(p []byte) (n int, err error)
}

type Writer interface {
    Write(p []byte) (n int, err error)
}

type FileHandle interface {
    Reader
    Writer
    Close() error
}
```

В итоге интерфейс FileHandle будет содержать три метода: Read, Write и Close.

Композиция интерфейсов — очень важная и удобная в применении вещь. Она позволяет встроить в интерфейс требования другого интерфейса, включая интерфейсы из других пакетов. Например, если компания планирует отправлять всех своих сотрудников на обучение, то она может просто встроить интерфейс Student в интерфейс Worker.  Компания может не знать, какие требования задаёт интерфейс Student, но перекладывает ответственность за это на сотрудников.


### Ключевые мысли
* Интерфейс — это тип языка Go, который описывает не структуру переменной, а её поведение.
* Реализация интерфейса — это создание такого типа, который реализует поведение, описанное интерфейсом.
* Переменной типа интерфейс может быть присвоен объект любого типа, если он удовлетворяет этому интерфейсу.
* С точки зрения языка типы T и *T — разные.
* Интерфейс описывается в том же пакете, в котором применяется, и является частью его контракта для внешних пакетов, которые его реализуют.
* Интерфейсы позволяют снизить связность кода.
* Интерфейсы позволяют реализовать полиморфизм и сокрытие в парадигме ООП.
* Интерфейсы можно комбинировать.
* Можно писать свои интерфейсы и к библиотечному коду.


## Интерфейсы в стандартной библиотеке

В предыдущем уроке вы познакомились с интерфейсами в Go. Среди них были Stringer, Reader и Writer, уже находящиеся в стандартной библиотеке, поэтому в продакшен-код их достаточно импортировать, чтобы не писать с нуля. О других популярных интерфейсах из стандартной библиотеки расскажем ниже.

### fmt.Stringer

```
type Stringer interface {
    String() string
}
```

Этот интерфейс часто используется, когда нужно одной строчкой залогировать сложный объект. Определение интерфейса лежит в пакете fmt.

Для примера возьмём структуру User и допишем к ней реализацию интерфейса fmt.Stringer:

```
type User struct {
    Email        string
    PasswordHash string
    LastAccess   time.Time
}

func (u User) String() string {
    return "user with email " + u.Email
}

func main() {
    u := User{Email: "example@yandex.ru"}
    fmt.Printf("Hello, %s", u)
}

// Hello, user with email example@yandex.ru 
```

Функция fmt.Printf использовала реализацию интерфейса. 


### Пакет io

Пакет io предназначен для реализации средств ввода-вывода, однако в нём есть несколько удобных интерфейсов, которые применяются и для других целей.

### io.Reader

```
type Reader interface {
    Read(p []byte) (n int, err error)
}
```

Этот интерфейс описывает чтение из любого потока данных: сети, файловой системы или буфера. Определение интерфейса лежит в пакете io.

Метод Read считывает в переданный слайс байт данные из источника. В качестве источника могут выступать любые данные, которые описаны в типе. То есть считываем их структуры и записываем в байты. Количество считанных байт неявно задаётся размером буфера — длиной слайса. 

Объясним возможности интерфейса на примере. Есть буфер — и нужно прочитать байты из него. В пакете strings лежит функция strings.NewReader, которая оборачивает обычную строку в структуру strings.Reader. Эта структура имеет метод Read, значит, она реализует интерфейс io.Reader:

```
s := `Hodor. Hodor hodor, hodor. Hodor hodor hodor hodor hodor. Hodor. Hodor! 
Hodor hodor, hodor; hodor hodor hodor. Hodor. Hodor hodor; hodor hodor - hodor, 
hodor, hodor hodor. Hodor, hodor. Hodor. Hodor, hodor hodor hodor; hodor hodor; 
hodor hodor hodor! Hodor hodor HODOR! Hodor hodor... Hodor hodor hodor...`

// обернём строчку в strings.Reader
r := strings.NewReader(s)

// создадим буфер на 16 байт
b := make([]byte, 16)

for {
    // strings.Reader скопирует 16 байт в b
    //
    // в структуре запоминается последний указатель,  
    // то есть следующий вызов скопирует следующую порцию из 16 байт
    //
    // также метод возвращает количество прочитанных байт n и ошибку err
    //
    // когда дойдём до конца строки, метод отдаст ошибку io.EOF
    n, err := r.Read(b)

    // при работе с интерфейсом io.Reader нужно в первую очередь проверять
    // n > 0, затем err != nil
    //
    // могут быть ситуации, когда часть данных получилось прочитать
    // и сохранить в буфер, а затем произошла ошибка 
    //
    // в таком случае будут одновременно n > 0 и err != nil
    if n > 0 {
        // выведем на экран содержимое буфера
        fmt.Printf("%v\n", b)
    }

    if err != nil {
        // если дочитали до конца, выходим из цикла
        if errors.Is(err, io.EOF) {
            break
        }

        // обрабатываем ошибку чтения
        fmt.Printf("error: %v\n", err)
    }
}
```

Удобство применения io.Reader в том, что его пользователь может вообще не знать, откуда берутся данные: из файла, сети или генерируются на лету. Интерфейс описывает унифицированный метод работы с ними.

Для закрепления реализуем генератор случайных данных:

```
package randbyte

import (
    "io"
    "math/rand"
)

type generator struct {
    rnd rand.Source // Генератор случайных чисел. Вообще rand.Rand уже реализует интерфейс io.Reader, но для примера мы реализуем его самостоятельно.
}

// New — обратите внимание, что мы возвращаем generator, присвоенный интерфейсу io.Reader, сама структура generator неэкспортируемая.
// Мы скрыли внутри пакета все детали.
func New(seed int64) io.Reader {
    return &generator{
        rnd: rand.NewSource(seed),
    }
}

// Read — реализация io.Reader
func (g *generator) Read(bytes []byte) (n int, err error) { // error — это тип ошибки, подробнее мы рассмотрим его в следующем разделе.
    for i := range bytes {
        randInt := g.rnd.Int63()  // функция возвращает положительное число в пределах от 0 до 2^63
        randByte := byte(randInt) // приводим к типу byte
        bytes[i] = randByte
    }
    return len(bytes), nil
}
```
```
package main

import (
    "example/randbyte"
    "fmt"
    "time"
)

func main() {

    // создаём генератор случайных чисел
    generator := randbyte.New(time.Now().UnixNano()) // в качестве затравки передаём ему текущее время, и при каждом запуске оно будет разным.

    buf := make([]byte, 16)

    for i := 0; i < 5; i++ {
        n, _ := generator.Read(buf) // единственный доступный метод, но он нам и нужен.
        fmt.Printf("Generate bytes: %v size(%d)\n", buf, n)
    }

}
```
Мы реализовали простой генератор случайных байт. 

В последнем рассмотренном примере реализация функции Read не очень эффективна — генератор случайных чисел возвращает 64-битное число, то есть 8 байт. Из них используем только 1.

Попробуйте реализовать более эффективное решение. Для упрощения примера считайте, что функция будет принимать только слайсы, длина которых кратна 8. Для преобразования числа в слайс байт можно использовать функцию из стандартной библиотеки binary.LittleEndian.PutUint64([ ]byte, uint64).

```
// Read — реализация io.Reader
func (g *generator) Read(bytes []byte) (n int, err error) { // error это тип ошибки, подробнее мы рассмотрим его в следующем разделе.
    for i := 0; i+8 < len(bytes); i += 8 {
        binary.LittleEndian.PutUint64(bytes[i:i+8], uint64(g.rnd.Int63()))
    }
    return len(bytes), nil
}
```


### io.Writer

```
type Writer interface {
    Write(p []byte) (n int, err error)
} 
```

Этот интерфейс означает запись в любой возможный поток данных: сетевой сокет, файл или буфер. Определение интерфейса лежит в пакете io.

C этим интерфейсом ситуация, обратная io.Reader. Он позволяет записать переданный ему слайс байт куда-то. Куда именно — определяется реализацией.

Для примера соберём большую строку из подстрок, вот только не через оператор +=, потому что тогда на каждую итерацию будет лишняя копия всей строки. В пакете strings есть структура strings.Builder для сборки строки без избыточного копирования. Эта структура имеет метод Write, значит, она реализует интерфейс io.Writer:

```
// создаём strings.Builder
w := strings.Builder{}

for i := 0; i < 50; i++ {
    // функция fmt.Fprintf принимает аргументом io.Writer
    // благодаря этому можно записывать форматированный вывод
    fmt.Fprintf(&w, "%v", math.NaN())
}

w.Write([]byte("... BATMAN!"))

// выводим собранную строку
fmt.Printf("%s\n", &w)
```

Приведём пример реализации интерфейса Write. Предположим, что мы хотим посчитать хеш от некоторого массива байт или наборов массивов. Для простоты возьмём упрощённую функцию хеширования:
```
package hashbyte

import "io"

type Hasher interface {
    io.Writer // мы встроили интерфейс io.Writer в наш интерфейс, чтобы задать требование по наличию метода Write
    Hash() byte
}

type hash struct {
    result byte
}

func New(_init byte) Hasher {
    return &hash{
        result: _init,
    }
}

// Write — сюда может быть записан массив байт любой длины, для которой будет подсчитываться хэш.
func (h *hash) Write(bytes []byte) (n int, err error) {
    // обновляем хеш для каждого байта, записанного в хешер
    for _, b := range bytes {
        h.result = (h.result^b)<<1 + b%2 
    }
    return len(bytes), nil
}

func (h hash) Hash() byte {
    return h.result
}
```

Теперь используем её в нашей программе: 
```
func main() {

    // создаём генератор случайных чисел
    generator := randbyte.New(time.Now().UnixNano()) // в качестве затравки передаём ему текущее время — при каждом запуске оно будет разным

    buf := make([]byte, 16)

    for i := 0; i < 5; i++ {
        n, _ := generator.Read(buf)
        fmt.Printf("Generate bytes: %v size(%d)\n", buf, n)
    }

    hasher := hashbyte.New(0)
    hasher.Write(buf)
    fmt.Printf("Hash: %v \n", hasher.Hash())

}
```


### Функции-утилиты для io.Reader и io.Writer

### io.Copy

> func Copy(dst Writer, src Reader) (written int64, err error)

Функция копирует все байты из io.Reader в io.Writer.

Данные будут считываться до тех пор, пока функция Read не вернёт вторым аргументом ошибку. Если в качестве ошибки будет возвращено значение io.EOF, то выполнение функции закончится без ошибок. Также будет возвращено количество байт. 

io.EOF происходит от end of frame (конец файла) — исторически так назывался специальный символ, который означал конец файла. 

Приведём простой пример. Напишем функцию, копирующую содержимое одного файла в другой:

```

func CopyFile(srcFileName, dstFileName string) error {
    srcFile, err := os.Open(srcFileName)
    if err != nil {
        return err
    }
    dstFile, err := os.Create(dstFileName)
    if err != nil {
        return err
    }
    n, err := io.Copy(dstFile, srcFile)
    if err != nil {
        return err
    }
    fmt.Printf("Copied %d bytes from %s to %s", n, srcFileName, dstFileName)
    return nil
}
```

Структура типа os.File реализует интерфейсы io.Reader и io.Writer. 

Было бы просто считать весь исходный файл в память и затем скопировать его в новый. Но если исходный файл занимает сотни гигабайт? io.Copy работает умнее, считывая и записывая данные небольшими кусочками, поэтому для подобных операций рекомендуется использовать именно её.


### io.CopyN

> func CopyN(dst Writer, src Reader, n int64) (written int64, err error) 

Функция копирует все байты из io.Reader в io.Writer, но не более n байт. То же самое, что и Copy, но с ограничением — можно использовать с источниками данных, которые слишком большие или вообще бесконечные. Например, напишем функцию, которая будет сохранять данные из нашего генератора случайных чисел в файл.

```
// Dump — сохраняет вычисленные данные в файл
func (g generator) Dump(n int64, dst *os.File) error {
    _, err := io.CopyN(g, dst, n)
    return err
}
```

Если бы мы использовали Copy, то программа продолжила бы работать до переполнения диска. 


### io.ReadAll

> func ReadAll(r Reader) ([]byte, error) 

Функция считывает все байты из io.Reader. Чтение закончится, когда io.Reader вернёт io.EOF. 


### io.ReadAtLeast

> func ReadAtLeast(r Reader, buf []byte, min int) (n int, err error) 

Функция считывает байты из io.Reader c ограничением: если прочитанных байт оказалось меньше, чем n, вернётся ошибка io.ErrUnexpectedEOF. Это используется при парсинге бинарных данных, чтобы гарантировать, что нужное минимальное количество байт будет вычитано.


### Другие интерфейсы пакета io

Мы привели примеры основных методов работы с функциями и интерфейсами ввода-вывода. Кроме них, в пакете осталось ещё много интересного. Рекомендуем открыть документацию пакета io, чтобы посмотреть на определения остальных интерфейсов. io.Reader и io.Writer — основные интерфейсы, но могут пригодиться и другие.


В пакете io есть функция LimitReader(r io.Reader, n int64) io.Reader. Она ограничивает количество байт, которое можно вычитать из io.Reader. 
```
package main

import (
    "io"
    "log"
    "os"
    "strings"
)

type LimitedReader struct {
    reader io.Reader
    //  запоминаем количество считанных байт
    left   int
}

func LimitReader(r io.Reader, n int) io.Reader {
    return &LimitedReader{reader: r, left: n}
}

func (r *LimitedReader) Read(p []byte) (int, error) {
    if r.left == 0 {
        return 0, io.EOF
    }
    if r.left < len(p) {
        p = p[0:r.left]
    }
    n, err := r.reader.Read(p)
    r.left -= n
    return n, err
}

func main() {
    r := strings.NewReader("some io.Reader stream to be read\n")
    lr := LimitReader(r, 4)

    _, err := io.Copy(os.Stdout, lr)
    if err != nil {
        log.Fatal(err)
    }
}
```


## Пустой интерфейс и приведение типов

В предыдущих уроках в определениях функций и структур использовались интерфейсы. Но бывают ситуации, когда не всегда можно указать конкретные типы переменных. Например, если получаем JSON-документ от пользователя, то структура этого документа может быть любой. 

Разрешить функции принимать произвольный параметр можно с помощью **пустого интерфейса** — интерфейса без методов.

Действительно, так как интерфейс является набором требований к типу, то пустой интерфейс ничего от типа не требует. Он может быть чем угодно. Однако и использовать переменную типа пустого интерфейса невозможно.

```
func PassAnyType(v interface{}) {
    // ...
}
```

***В Go 1.18 у типа interface{} появился более короткий и понятный псевдоним any (от англ. any — любой).***

Но с переменной v нельзя ничего сделать. Нужно привести её к определённому типу оператором v.(Тип). 

Оператор приведения типа приводит переменную интерфейсного типа к конкретному типу или другому интерфейсу.  

```
func PassAnyType(v interface{}) {
    i := v.(int)     // если v не число, то будет паника, то есть программа не сможет работать и прекратит выполнение

    i, ok := v.(int) // альтернативный формат: если v не число, то будет false
                     // паники не будет 
    if ok {
        // ...
    }
}
```

Второй вариант использования более предпочтителен.

Оператором switch можно лаконично запрограммировать логику относительно каждой проверки типа. Для примера напишем свою реализацию функции fmt.Printf:

```
func Printf(v interface{}) {
    switch v2 := v.(type) {
    case int:
        fmt.Print("Это число " + strconv.FormatInt(v2, 10))
    case string:
        fmt.Print("Это строка " + v2)
    case Stringer:
        fmt.Print("Это тип, реализующий Stringer, " + v2.String())
    default:
        fmt.Print("Неизвестный тип")
    }
}
```

Попробуйте реализовать обобщение операции умножения для чисел и строк. Если первый аргумент функции — строка, то повторить её b раз, а если число, то вернуть a*b. 
```
func Mul(a interface{}, b int) interface{} {
    switch va := a.(type) {
    case int:
        return va * b
    case string:
        return strings.Repeat(va, b)
    case fmt.Stringer:
        return strings.Repeat(va.String(), b)
    default :
        return nil
    }
}
```


### Внутреннее устройство интерфейсов

Чтобы понять, каким образом интерфейсы приводятся к другим типам, следует разобраться, как устроен интерфейс изнутри.

Соединим примеры из предыдущего и текущего уроков:
```
type User struct {
    Email      string
    Password   string
    LastAccess time.Time
}

func (u User) String() string {
    return "user with email " + u.Email
}

func Printf(v Stringer) {
    fmt.Print("Это тип, реализующий Stringer, " + v.String())
}

func main() {
    u := User{Email: "example@yandex.ru"}
    Printf(u)
}
```

Вот какие данные будут храниться в переменной v Stringer:

<img src="https://pictures.s3.yandex.net/resources/8.3._1643217711.png">

На схеме видно, что интерфейс состоит из двух указателей: на метаданные типа и на сами данные. При приведении типа используются эти метаданные, чтобы вычислить, какой конкретный тип представляет этот интерфейс и как правильно разыменовать указатель на данные.

Почему так устроено? Всё дело в том, что переменной интерфейсного типа могут быть присвоены данные разного размера. Например, интерфейсу Stringer может удовлетворять и большая сложная структура, и пользовательский int. Поэтому сохраняем данные по указателю. А вот в itable храним метаинформацию о типе, который там содержится.

Когда присваиваем переменную конкретного типа, происходит следующее:

```
// Компилятор создаёт в программе метаданные со списком методов интерфейса
type Stringer interface {
    String() string
}

// Компилятор создаёт в памяти структуру с описанием типа User, его полей
type User struct {
    
} 

var user Stringer // Объявляется переменная интерфейса — её значение пока что равно nil, в памяти выделяется два машинных слова под указатели tab и data  

// Переменной присваивается конкретное значение. Проверяется, удовлетворяет ли тип переменной интерфейсу. 
// При этом в tab записывается указатель на структуру itable, связывающий информацию о типе User и Stringer,
// а в data — указатель на User{}
user := User{}

// Интересно, что связывание типа и интерфейса происходит не на этапе компиляции, иначе размер программы был бы слишком большим, а на этапе выполнения. Эта операция кешируется, так что выполняется всего один раз и не влияет на производительность.

// Проверяем, что в tab у нас лежит действительно тип User — и если да, то ok true, а в переменную u копируется значение data.   
// Если типы не совпадают, то ok — false
u, ok := user.(User)
```

***Интерфейсная переменная по природе относится к ссылочному типу. Если передать её в функцию, то она скопируется, но, так как указатели будут указывать на ту же исходную переменную, изменение переменной через вызов методов может изменить данные. ***

В Go есть особенность, связанная с nil. Посмотрите ещё раз на схему: интерфейс может быть nil, а может быть с nil-указателем на данные. Покажем пример, где эта особенность приводит к ошибке:

```
// Собственный тип для ошибок. Аналогичен стандартному error
type Error interface {
    Error() string
}

// MyError — структура, реализующая нашу ошибку
type MyError struct {
    // ...
}

// Error — метод для удовлетворения интерфейсу Error
func (e *MyError) Error() string {
    return "..."
}


// переменная типа ошибки — указатель на пустую структуру
var ErrFriday13 = &MyError{}

func CheckTodayIsOkay() Error {
    var err *MyError // указатель на переменную типа Error
    // получаем текущее время
    t := time.Now()
    // если день недели пятница и число месяца 13, то вернём ошибку  
    if t.Weekday() == time.Friday && t.Day() == 13 {
        err = ErrFriday13
    }
    // вернём ошибку ... указатель же nil
    return err
}

func main() {
    err := CheckTodayIsOkay()
    // проверяем err на nil — и внезапно всегда не nil 
    if err != nil {
        fmt.Println("error is not nil")
        return
    }

    fmt.Println("error is nil")
}
```

Код выведет строчку "error is not nil", потому что Go обернёт nil-указатель *MyError в не-nil-интерфейс Error.
То есть мы присвоили переменной типа interface{} переменную определённого типа. Это значит, что метаданные непустые. Исправить проблему можно так:
```
func CheckTodayIsOkay() Error {
    var err Error

    t := time.Now()
    if t.Weekday() == time.Friday && t.Day() == 13 {
        err = ErrFriday13
    }

    return err
}
```

В этом случае код выведет строчку "error is nil", потому что сам интерфейс Error будет nil.


### Сравнение интерфейсов

Сравнение интерфейсных типов имеет одну особенность, которую важно знать, так как она может привести к неочевидным ошибкам. Рассмотрим следующий пример:

```
type Stringer interface {
    String string
}

// создадим свой собственный тип на основе map 
type MyMap map[string]string

func (m MyMap) String () string {
    return fmt.Sprintf("%v", m)
}

// И ещё один тип на основе int
type MyInt int

func (m MyInt) String () string {
    return fmt.Sprintf("%v", m)
}

func main () {
    var mm MyMap
    var mi MyInt
    
    mm = MyMap{}
    mi = MyInt(5)
    
    fmt.Println(mm == mi) // false 
    fmt.Println(mm == mm) // Паника!
}
```

На первый взгляд, в программе творится нечто странное: с одной стороны, мы сравнили без ошибок мапу и целое, с другой — получили ошибку при сравнении переменной с самой собой.

Всё дело в том, что интерфейсы сравниваются по цепочке. Сначала сравнивается тип: если типы переменных внутри разные, то вернётся false; если одинаковые, то сравниваются уже сами данные. А map сравнивать между собой нельзя, и получаем панику.


### Ключевые мысли

* Интерфейсные переменные по своей природе динамичны. Их можно преобразовать к переменным другого типа через операцию приведения типа a.(type).
* Интерфейс изнутри представляет собой два указателя — на обёрнутую переменную и на информацию о её типе. Преобразование типа изменяет информацию о типе либо возвращает обёрнутую переменную.
* Операция приведения типа — это не то же самое, что преобразование типа.
* Интерфейс, равный nil, и интерфейс, оборачивающий nil, — разные вещи.
* Сравнение интерфейсов необходимо делать аккуратно.
* Наилучшим вариантом использования интерфейса является всё же использование не пустого, а конкретного интерфейса и обращение к его методам. Однако иногда без них не обойтись.


## Рефлексия

### Что такое рефлексия

Рефлексией в программировании называют возможность получить информацию о типе из переменной этого типа. Проще говоря, рефлексия позволяет получать информацию о коде программы и менять его во время выполнения.

Рефлексия обычно применяется для работы с данными, тип которых неизвестен при компиляции. Например, по сети могут приходить какие-то данные, которые должны быть уложены в структуры. Однако можно не знать, что это за данные, поэтому в таких случаях напрашивается возможность создавать структуры данных на лету. 

Следует отметить, что в большинстве задач, стоящих перед разработчиком, рефлексия не применяется. Тем не менее она используется в популярном пакете encoding/json и многих других. Это хороший аргумент, чтобы изучить рефлексию и понять, как она работает.

***Для работы с рефлексией в языке Go есть пакет reflect из стандартной библиотеки.***

В этом уроке вы познакомитесь с некоторыми возможностями пакета reflect. Функции пакета работают с произвольными статическими типами (interface{}) и позволяют получать метаинформацию о них. С помощью этого пакета можно динамически создавать типы в ходе выполнения приложения (в runtime).


### DeepEqual

Иногда возникает потребность сравнить две переменные одного типа по значению, и бывают случаи, что простой подход с использованием == не срабатывает. Тогда нужно заглянуть глубже, сравнить все значения, лежащие в слайсах и мапах, под указателями. 

Рассмотрим простой пример наивного подхода:
```
type MyType struct {
    IntField   int
    StrField   string
    PtrField   *float64
}

func (mt MyType) IsEqual(mt2 MyType) bool {
    return mt == mt2
}

func main() {
    floatValue1, floatValue2 := 10.0, 10.0
    a := MyType{IntField: 1, StrField: "str", PtrField: &floatValue1}
    b := MyType{IntField: 1, StrField: "str", PtrField: &floatValue2}

    fmt.Printf("Равенство a и b: %v\n", a.IsEqual(b))
}

// Равенство a и b: false 
```

Получаем false, хотя внешне содержимое этих переменных кажется равным. В чём подвох?

В примере определены тип MyType и метод для сравнения двух экземпляров типа IsEqual.

Выполнение этого сниппета выводит в консоль false, хотя значения всех полей объектов a и b равны. Это происходит потому, что прямое сравнение указателей (поле PtrField) сопоставляет адреса, но не значения. Если оба указателя будут иметь значения nil, то код выведет true.

Изменим спецификацию типа:
```
type MyType struct {
    IntField   int
    StrField   string
    PtrField   *float64
    SliceField []int
}
```

Компиляция такого кода выведет ошибку, так как для типа SliceField не определена операция ==. Добавление в структуру поля ссылочного типа (или в поле вложенной структуры) приводит к тому, что использовать оператор == для её прямого сравнения невозможно. Это справедливо не только для структур, но и для всех пользовательских типов, например type MySlice []int.

***Одно из решений — изменить код метода IsEqual и добавить туда несколько if. Написание метода или функции сравнения — распространённая практика в Go, так как язык не позволяет перегружать операторы (== в данном случае).***

Пакет reflect предлагает следующее решение:

```
func (mt MyType) IsEqual(mt2 MyType) bool {
    return reflect.DeepEqual(mt, mt2)
}

func main() {
    floatValue1, floatValue2 := 10.0, 10.0
    a := MyType{IntField: 1, StrField: "str", PtrField: &floatValue1, SliceField: []int{1}}
    b := MyType{IntField: 1, StrField: "str", PtrField: &floatValue2, SliceField: []int{1}}

    fmt.Printf("Равенство a и b: %v\n", a.IsEqual(b))
}

// Равенство a и b: true
```

Функция сравнивает значения всех элементов типа, включая вложенные. В документации можно ознакомиться со всеми критериями для сравнения функции DeepEqual.

На практике DeepEqual используется нечасто, так как вызов этой функции рекурсивно пробегает по всем элементам типа, на что уходит много времени процессора. Чаще всего IsEqual пишут вручную, ограничивая область сравнения требуемой логикой приложения.

DeepEqual позволяет сравнить две переменные одного типа по значению, даже если эти переменные имеют сложную структуру данных, например содержат ссылки на другие переменные.


### Value и ValueOf()

В прошлом уроке мы обсуждали приведение интерфейсов. Интерфейс одного типа можно попробовать привести к другому типу. Однако что, если мы не знаем, к какому типу нужно привести переданный объект?

Пакет reflect представляет расширенные возможности по работе с приведением типов и их исследованию во время исполнения программы.

Представьте, что мы пишем некую библиотеку, которая должна работать с разнообразными типами данных. В качестве примера можно привести пакет encoding/json, который умеет принимать и сериализировать любые структуры.

Одного приведения здесь явно недостаточно, ведь перед разработчиком зачастую встают, например, такие вопросы: 

* Сколько полей у структуры?
* Какой у них тип?
* Как они называются? Хочется получить эти названия в виде строки.

В то же время структура передаётся в нашу библиотеку, завёрнутой в пустой интерфейс.

Именно на эти вопросы призвана ответить рефлексия.

Каждое значение, вне зависимости от типа, можно привести к универсальному типу reflect.Value. Делается это через вызов reflect.ValueOf(v inteface()) Value. Эта функция принимает некоторое значение и возвращает Value. У самого же Value много методов, которые позволяют получить информацию как о типе, так и о значении. 

Рассмотрим некоторые из них.


### Type и Kind

Метод Type() возвращает тип объекта. 

Метод Kind() возвращает базовый тип объекта, то есть не пользовательский тип, а один из встроенных в язык Go: структуру, канал, слайс, функцию, массив и другие.

```
var varBool *bool
fmt.Println(reflect.ValueOf(varBool).Kind()) // ptr — указатель
fmt.Println(reflect.ValueOf(varBool).Type()) // *bool — указатель на bool

var varFloat float32
fmt.Println(reflect.ValueOf(varFloat).Kind()) // float32
fmt.Println(reflect.ValueOf(varFloat).Type()) // float32

var varMap map[string]int
fmt.Println(reflect.ValueOf(varMap).Kind()) // map  
fmt.Println(reflect.ValueOf(varMap).Type()) // map[string]int

varStruct := struct{Value int}{}
fmt.Println(reflect.ValueOf(varStruct).Kind()) // struct
fmt.Println(reflect.ValueOf(varStruct).Type()) // struct { Value int }
```

Тип reflect.Type содержит описание Go-типа. Тип reflect.Kind задаёт множество базовых типов Go: структуру, канал, слайс, функцию, массив и другие. То есть Type описывает, каким конкретно типом является значение, а Kind — каким видом типа он является.

Довольно полезная вещь, чтобы понять, что нам передали: структуру, массив или просто целое число.


### Проверка на nil

В прошлом уроке мы затрагивали сравнение интерфейсов с nil и выяснили, что nil, может быть как значением самого интерфейса, так и значением величины, на которую он указывает.

Попробуем реализовать наивную реализацию сравнения.

```
type MyType struct{}

func NaiveIsNil(obj interface{}) bool {
    return obj == nil
}

func main() {
    var t *MyType
    fmt.Printf("Проверка типа (%v) на nil: %v\n", reflect.TypeOf(t), NaiveIsNil(t)) // TypeOf возвращает тип переданного объекта. 
}

// Проверка типа (*main.MyType) на nil: false
```

Что-то явно пошло не так. Мы передали в функцию nil и ожидали true. 

Переменная t — указатель на тип MyType. При таком объявлении переменной не задаётся значение указателя, и технически он пуст, но прямое сравнение с nil выдаёт false. Причина была рассмотрена в предыдущем уроке, поэтому сейчас не будем останавливаться на этом подробно. Используя пакет reflect, напишем универсальное решение для подобной проверки:
```
func IsNil(obj interface{}) bool {
    if obj == nil {
        return true
    }

    objValue := reflect.ValueOf(obj)
    // проверяем, что тип значения ссылочный, то есть в принципе может быть равен nil
    if objValue.Kind() != reflect.Ptr {
        return false
    } 
    // проверяем, что значение равно nil 
    //  важно, что IsNil() вызывает панику, если value не является ссылочным типом. Поэтому всегда проверяйте на Kind() 
    if  objValue.IsNil() {
        return true
    }

    return false
}
```

Вот ещё несколько полезных методов:
```
varInt := 100
varIntValue := reflect.ValueOf(varInt)
fmt.Println(varIntValue.IsZero()) // false
fmt.Println(varIntValue.Int())    // 100

var varPtr *int
varPtrValue := reflect.ValueOf(varPtr)
fmt.Println(varPtrValue.IsNil())  // true
fmt.Println(varPtrValue.IsZero()) // true
```

Метод IsZero() сравнивает значение со значением по умолчанию (для int — 0, для указателя — nil и т. д.).

Метод IsNil() сравнивает значение с nil и применим только к типам, которые поддерживают nil (chan, slice, map и т. д.).

Как и с другими типами пакета, с Value нужно обращаться осторожно, потому что неверное использование его методов приведёт к панике. Например:

```
var varBool *bool
varBoolValue := reflect.ValueOf(varBool)
fmt.Println(varBoolValue.IsNil())        // true
fmt.Println(varBoolValue.IsZero())       // true
fmt.Println(varBoolValue.Elem().Bool())  // panic: попытка получить значение для пустого Value
```

Метод Elem() возвращает значение (тоже тип Value), которое описывается интерфейсом Value (varBoolValue в данном случае).

По сути, метод Elem() — это разыменование: возвращается значение, на которое указывает Value, бывший указателем. 

Исправим предыдущий пример и покажем, как выставить значение для указателя через рефлексию:

```
var varBool *bool
fmt.Println(reflect.ValueOf(varBool).IsNil())  // true

trueVal := true
reflect.ValueOf(&varBool).Elem().Set(reflect.ValueOf(&trueVal))

fmt.Println(reflect.ValueOf(varBool).IsNil())       // false
fmt.Println(reflect.ValueOf(varBool).Elem().Bool()) // true — получить значение через рефлексию
fmt.Println(*varBool)                               // true — получить значение без рефлексии
```


Выставляем значение переменной varBool, используя метод Set(val reflect.Value) и передавая в него подходящее по типу Value.


### Fields и NumFields — итерация по полям структуры

Если вы когда-либо писали на низкоуровневом С, то наверняка вам приходилось работать со структурами как с массивами байт. Просто брали указатель на структуру и двигались по ней этим указателем, получая доступ к полям. Процесс крайне опасный и неудобный, однако, надо признать, крайне эффективный в части производительности.

***В Python тоже есть возможность получить доступ к элементам объекта класса как к словарю. В Go тоже хотелось бы иметь такую возможность. Пакет reflect её также предоставляет, однако следует отметить, что производительность такого решения ниже, чем обычного доступа к полям структур.***

Рассмотрим на примере:
```
package main

import "reflect"

//
func ExtendedPrint(v interface{}) {
    val := reflect.ValueOf(v)
    //  проверяем, а не передали ли нам указатель на структуру
    switch val.Kind() {
    case reflect.Ptr:
        if val.Elem().Kind() != reflect.Struct {
            fmt.Printf("Pointer to %v : %v", val.Elem().Type(), val.Elem())
            return
        }
        // если всё-таки это указатель на структуру, дальше будем работать с самой структурой
        val = val.Elem()

    case reflect.Struct: // работаем со структурой
    default:
        fmt.Printf("%v : %v", val.Type(), val)
        return
    }

    fmt.Printf("Struct of type %v and number of fields %d:\n", val.Type(), val.NumField())
    for fieldIndex := 0; fieldIndex < val.NumField(); fieldIndex++ {
        field := val.Field(fieldIndex) // field — тоже Value
        fmt.Printf("\tField %v: %v - val :%v\n", val.Type().Field(fieldIndex).Name, field.Type(), field)
        // имя поля мы получаем не из значения поля, а из его типа. 
    }
}

func main() {
    s := MyStruct{
        A: 3,
        B: "some",
        C: false,
    }
    s1 := &MyStruct{
        A: 7,
        B: "text",
        C: true,
    }

    ExtendedPrint(s)
    ExtendedPrint(s1)
    ExtendedPrint(struct {
        E int
        C string
    }{2, "other text"})
    ExtendedPrint("some string")
}
```
Вывод будет таким:
```
Struct of type main.MyStruct and number of fields 3:
  Field A: int - val :3
  Field B: string - val :some
  Field C: bool - val :false
Struct of type main.MyStruct and number of fields 3:
  Field A: int - val :7
  Field B: string - val :text
  Field C: bool - val :true
Struct of type struct { E int; C string } and number of fields 2:
  Field E: int - val :2
  Field C: string - val :other text
string : some string
```

Получаем довольно удобную и интересную особенность, которая часто используется для исследования переданных структур. Если вам нужно получить доступ к одному из полей переданной структуры по имени, используйте полезные функции:

* FieldByName(name string) — возвращает Value поля структуры по имени.
* FieldByIndex(i int) — возвращает поле структуры по индексу.

Для методов типа есть аналогичные функции. 


### Изменение поля структуры

С помощью рефлексии можно изменить переданный объект. 

Однако не всякий объект может быть изменён. Чтобы узнать, можно ли изменить Value, используется метод CanSet().

Например, реализуем функцию, которая определяет, есть ли у входной структуры поле с именем. И если такое поле есть, она его изменит.

```
func ChangeFieldByName(v interface{}, fname string, newval int) {
    val := reflect.ValueOf(v)
    if val.Kind() == reflect.Ptr {
        val = val.Elem()
    }
    if val.Kind() != reflect.Struct {
        return
    }

    field := val.FieldByName(fname)
    if field.IsValid() {
        if field.CanSet() {
            switch field.Kind() {
            case reflect.Int:
                field.SetInt(int64(newval))
            case reflect.String:
                field.SetString(strconv.Itoa(newval))
            }
        }
    }
}
```

***Важно***
***CanSet проверяет, отразится ли изменение Value на переданной ей переменной. Если переменная передана в ValueOf по значению, то функция не сработает. Ещё один важный момент: изменить значение можно только для экспортируемых полей.***


### Динамическая информация о типе (парсинг тегов)

Для каждого поля структуры можно задать теги — строку с дополнительной информацией по этому полю. Например, можно указать настройки сериализации в формат JSON. Теги задаются в формате key:value, причём может быть задано несколько тегов, разделённых пробелами. При парсинге тегов они преобразуются в набор пар «ключ-значение».

Обычно теги используются тогда, когда недостаточно информации о поле структуры, полученной через рефлексию. К примеру, хотелось бы иметь точное название поля структуры для сериализации.

Используя пакет reflect, напишем функцию GetStructTags, которая вернёт информацию обо всех заданных тегах структуры и их значениях:

```
type (
    // FieldsInfo содержит информацию о полях структуры (ключ: имя поля).
    FieldsInfo map[string]FieldInfo

    // FieldInfo содержит информацию о поле структуры.
    FieldInfo struct {
        // тип поля
        Type     string     `json:"type"`
        // теги
        Tags     TagsInfo   `json:"tags,omitempty"`
        // информация по полям вложенной структуры
        Embedded FieldsInfo `json:"embedded,omitempty"`
    }

    // TagsInfo содержит информацию о тегах (ключ: имя тега).
    TagsInfo map[string][]string
)

// String возвращает строковую репрезентацию типа FieldsInfo.
func (f FieldsInfo) String() string {
    bz, _ := json.MarshalIndent(f, "", "   ")
    return string(bz)
}

// GetStructTags возвращает информацию по каждому полю структуры.
func GetStructTags(obj interface{}) (retInfos FieldsInfo) {
    retInfos = make(FieldsInfo)

    // получаем описание типа переданного объекта
    // далее по коду явно передаём в функцию тип `reflect.Type`, поддержим здесь этот случай рекурсивного вызова
    var objType reflect.Type
    if t, ok := obj.(reflect.Type); ok {
        objType = t
    } else {
        objType = reflect.ValueOf(obj).Type()
    }

    // чиним вход: если передали указатель, получим описание типа под указателем
    if objType.Kind() == reflect.Ptr {
        objType = objType.Elem()
    }

    // проверка входа: если объект не структура, искать теги не нужно
    if objType.Kind() != reflect.Struct {
        return
    }

    // итерируемся по всем полям структуры
    // NumField() — возвращает количество полей в структуре
    for fieldIdx := 0; fieldIdx < objType.NumField(); fieldIdx++ {
        field := objType.Field(fieldIdx) // получаем поле структуры
        retInfos[field.Name] = FieldInfo{
            Type:     field.Type.String(), // тип структуры
            Tags:     parseTagString(string(field.Tag)), // теги структуры
            Embedded: GetStructTags(field.Type), // рекурсивно вызываем для каждого поля эту же функцию; если поле — структура, то пройдёмся и по ней.
        }
    }

    return
}

// parseTagString десериализует тег-строку поля структуры.
// Дедупликация имён тегов: первый по порядку (слева направо).
// Ограничения: значение тега не может содержать символы ':' и '"'.
func parseTagString(tagRaw string) (retInfos TagsInfo) {
    retInfos = make(TagsInfo)

    // пример строки: json:"name" pg:"nullable,sortable"
    for _, tag := range strings.Split(tagRaw, " ") {
        if tag = strings.TrimSpace(tag); tag == "" {
            continue
        }

        tagParts := strings.Split(tag, ":")
        if len(tagParts) != 2 {
            continue
        }

        tagName := strings.TrimSpace(tagParts[0])
        if _, found := retInfos[tagName]; found {
            continue
        }

        tagValuesRaw, _ := strconv.Unquote(tagParts[1])
        tagValues := make([]string, 0)
        for _, value := range strings.Split(tagValuesRaw, ",") {
            if value := strings.TrimSpace(value); value != "" {
                tagValues = append(tagValues, value)
            }
        }

        retInfos[tagName] = tagValues
    }

    return
}
```

Пример выполнения:
```
type (
    TestStruct struct {
        Id        string `json:"id" format:"uuid" example:"68b69bd2-8db6-4b7f-b7f0-7c78739046c6"`
        Name      string `json:"name" example:"Bob"`
        Group     Group  `json:"group"`
        CreatedAt int64  `json:"created_at" format:"unix" example:"1622647813"`
    }

    Group struct {
        Id             uint64   `json:"id"`
        PermsOverrides []string `json:"overrides" example:"USERS_RW,COMPANY_RWC"`
    }
)

func main() {
    var s *TestStruct
    fmt.Println(GetStructTags(s))
}
```

```
{
   "CreatedAt": {
      "type": "int64",
      "tags": {
         "example": [
            "1622647813"
         ],
         "format": [
            "unix"
         ],
         "json": [
            "created_at"
         ]
      }
   },
   "Group": {
      "type": "main.Group",
      "tags": {
         "json": [
            "group"
         ]
      },
      "embedded": {
         "Id": {
            "type": "uint64",
            "tags": {
               "json": [
                  "id"
               ]
            }
         },
         "PermsOverrides": {
            "type": "[]string",
            "tags": {
               "example": [
                  "USERS_RW",
                  "COMPANY_RWC"
               ],
               "json": [
                  "overrides"
               ]
            }
         }
      }
   },
   "Id": {
      "type": "string",
      "tags": {
         "example": [
            "68b69bd2-8db6-4b7f-b7f0-7c78739046c6"
         ],
         "format": [
            "uuid"
         ],
         "json": [
            "id"
         ]
      }
   },
   "Name": {
      "type": "string",
      "tags": {
         "example": [
            "Bob"
         ],
         "json": [
            "name"
         ]
      }
   }
}
```


## Ключевые мысли урока

Мы рассмотрели основные возможности применения рефлексии в языке Go. Рефлексия позволяет на основе переданной переменной узнать тип и значение этой переменной. Благодаря этому можно создавать гибкий код, работающий с очень широким набором типов входных данных. Однако следует помнить, что рефлексия замедляет работу программы. По возможности следует использовать другие подходы, так как работать такая программа будет крайне медленно.

Кроме того, мы исследовали:
* Определение типа переменной.
* Определение имён и количества полей структуры, а также доступ к ним по индексу.
* Изменение переменной через рефлексию.
* Использование тегов.