## Интерфейсы


В этой теме вы:

* изучите синтаксис определения и реализации интерфейсов;
* узнаете несколько рекомендаций по использованию интерфейсов.


### Концепция интерфейсов и их реализация

В языке Go интерфейс — это набор методов, которые могут быть реализованы типом. Иными словами, интерфейс — описание того, что может сделать тип. 

Если тип имеет методы, описанные в интерфейсе, то этот тип удовлетворяет интерфейсу.

Синтаксис интерфейса очень простой. Вот пример некоторого интерфейса. Обратите внимание, что интерфейс описываем как тип:

```
type MyInterface interface {
    Method1(int) int
    Method2(a string) string 
    //.... может быть ещё много методов
}
```

В фигурных скобках указывается имя метода, список его аргументов и возвращаемых значений. Названия аргументов могут быть опущены, поэтому достаточно указать тип. Но для лучшего понимания кода их лучше писать: описание метода Create(id int, name string, email string) bool более понятно, чем Create(int, string, string) bool, хотя формально эти методы идентичны.

Интерфейс описывает контракт между различными частями программы. Передавая некоторую переменную в разные части программы, описываем, какие методы ожидаем от этой переменной.

Основное назначение интерфейсов — реализация полиморфизма: с одной стороны, тип может реализовывать несколько интерфейсов в разных контекстах применения, с другой стороны, у нас есть возможность написания алгоритмов, работающих с разными типами данных.

Приведём простой пример. Представим, что у нас есть некоторая структура Person, описывающая человека. В различных областях жизни (и нашей программы) человек может выступать в разных ролях: например, быть студентом, работником, родителем и кем-нибудь ещё. Для конкретной области не имеет значения, кем он является в других. На работе от него ждут работы, в обучении — сдачи домашних работ. Как родитель он может сообщить информацию о детях. А ещё он может сообщать информацию о себе.

Опишем эти отношения в коде:
```
package person

// Person - структура, описывающая человека
type Person struct {
    name string
    homework string
    children []*Person
}

// DoHomework — делает домашнюю работу 
func (p Person) DoHomework() string {
    return p.homework
}

// Children — сообщает информацию о детях
func (p Person) Children() []*Person {
    return p.children
}
 
// Work — выполняет поручения на работе
func (p Person) Work( tasks []string ) string {
    s := p.name + " work:"
    for _,task :=  range tasks {
        s += "\n I do " + task    
    }   
    return s
}

// String — сообщает информацию о себе
func (p Person) String() string {
    return p.name
} 
```

<img src="https://pictures.s3.yandex.net/resources/173821653-602f9dc2-3c5c-42ac-a5e5-c09b9b7cbc1b_1655409675.png">

Естественно, не требуется одновременное наличие этих методов в разных участках программы. Более того, их вызов может нарушить нормальную работу программы.

Для примера опишем другой пакет, представляющий собой место работы:
```
package company

// Worker — интерфейс работника компании 
type Worker interface {
    // всё, что он должен уметь делать, — это работать
    Work(tasks []string) string
}

// Company — структура компании 
type Company struct {
    // personal — сотрудники компании
    // обратите внимание, мы создали слайс сотрудников компании, то есть слайс переменных интерфейсного типа Worker
    personal [] Worker
}

// Hire — наём нового сотрудника
// Сотрудник может быть любого типа: человек, робот или сторожевая собака. Главное, чтобы он умел работать, то есть удовлетворял интерфейсу Worker
// Go ещё на этапе компиляции проверяет, соответствует ли интерфейсу переданная переменная
func (с* Company) Hire( newbie Worker ) {
    с.personal = append(с.personal, newbie) 
}

// Process — работа конкретного сотрудника 
func (с Company) Process ( id int,  tasks []string) (res string) {
    return c.personal[id].Work(tasks)
}
```

***Важно***

***Обратите внимание, что для Person явно не указывается, что он реализует интерфейс Worker. Снова вспоминаем утиную типизацию: если что-то выглядит как утка, плавает как утка и крякает как утка, то это утка.***

В этом и есть суть полиморфизма. company может работать с разными сущностями, единственное требование к которым — уметь работать. Это требование и описывается через интерфейс. 

Теперь соединим эти пакеты вместе.
```
package main

import (
    "company"
    "person"
)

func main() {
    pers := person.Person{}
    comp := company.Company{}
    
    comp.Hire(pers) // мы передаём переменную типа Person в функцию, аргументом которой является переменная Worker! 
}
```

На этапе компиляции компилятор проверяет, можно ли person присвоить переменной типа Worker. Для этого проверяется, что тип Person имеет все методы интерфейса Worker. В нашем случае они есть, всё работает. 

C помощью интерфейсов можно написать код, абстрагированный от внешних модулей: при изменениях в них ничего не нужно переделывать в своём коде, и наоборот. 

Интерфейсы добавляют гибкости и снижают связность кода. Пакеты person и company ничего не знают друг о друге, но могут успешно взаимодействовать. 

Продолжим рассматривать наш пример.

Предположим, что мы решили добавить в нашу программу роботов, которые могут работать так же, как и люди:
```
package robot

import "fmt"

// Robot — тип робота
type Robot struct {
    model       string
    serialId    int
    workCounter int
}

func (r Robot) String() string {
    return fmt.Sprintf("Robot %s serialID %d", r.model, r.serialId)
}

// Work — робот выполняет работы и запоминает количество выполненных задач. Поэтому получатель метода — по указателю
func (r *Robot) Work(tasks []string) string {
    res := fmt.Sprintf("%s work:", r)
    for _, task := range tasks {
        res += "\n I do " + task
    }
    r.workCounter += len(tasks)
    return res
}
```

Так как тип *Robot реализует интерфейс Worker, то можно устроить робота на работу в компанию.

***Важно***

С точки зрения Go типы Robot и *Robot (указатель) — разные. В примере метод Work привязан именно к *Robot. Так как формально тип Robot не реализует интерфейс Worker, такой код не скомпилируется:

```
comp := company.Company{}

robo := Robot{};
comp.Hire(robo); 
```

Поэтому будем использовать указатель на робота. Действительно, в этом есть логика. Раз работа в компании изменяет внутреннее состояние робота, то нужно передать указатель именно на неё.
```
comp := company.Company{}

robo := &Robot{};
comp.Hire(robo); 
```

Такой код скомпилируется нормально. Обратите внимание, что в самой компании ничего не пришлось менять. Мы просто создали роботов, которые удовлетворяют всем её требованиям к сотрудникам. Если бы компания работала со структурами, то нам бы пришлось создавать отдельные методы работы в ней с роботами и с людьми. 


### Интерфейсы и код внешних библиотек

Теперь, когда вы знаете синтаксис описания и реализации интерфейсов, рассмотрим практики их использования.

Раз в Go не нужно явно указывать, что тип реализует интерфейс, можно писать свои интерфейсы и к библиотечному коду.

Допустим, вы пользуетесь готовой библиотекой, которая посылает сетевые запросы к API:

```
type BigAPIClient struct {
    // пропустим код
}

func (c *BigAPIClient) Connect() error {
    // ...
}

func (c *BigAPIClient) Close() error {
    // ...
}

func (c *BigAPIClient) FetchMessages() ([]Message, error) {
    // ...
}

func (c *BigAPIClient) SendMessage(email string, message string) error {
    // ...
}

func (c *BigAPIClient) SendStatus(status string) error {
    // ...
}
```

Допустим, вашему коду хватит двух методов. Если вы хотите протестировать интеграцию с этой библиотекой, вам в ней ничего не нужно исправлять. В Go можно легко заменить вызовы методов типа на вызовы методов интерфейса:

```
type Client interface {
    FetchMessages() ([]Message, error)
    SendMessage(email string, message string) error
}

func MyFunc(client Client) {
    // в параметрах вместо типа *BigAPIClient принимаем интерфейс Client
    // код функции и вызывающий код остаются без изменений

    messages, err := client.FetchMessages() 
    if err != nil {
        // ...
    }

    // ...
}

func main() {
    client := &BigAPIClient{}
    MyFunc(client)
}
```

Напишем тестовую заглушку, чтобы протестировать интеграцию.

```
type MockClient struct {
}

func (c *MockClient) FetchMessages() ([]Message, error) {
    return []Message{{Text: "привет"}, {Text: "тестовый пример"}}, nil
}

func (c *MockClient) SendMessage(email string, message string) error {
    // ...
}
```

Теперь функция одинаково работает как c библиотечными методами, так и с подменёнными тестовыми методами:

```
func main() {
    realClient := &BigAPIClient{}
    MyFunc(realClient)

    mockClient := &MockClient{}
    MyFunc(mockClient)
}
```

***Важно***

```
В коде библиотек можно встретить такую конструкцию:

var _ Client = (*MockClient)(nil) 

Эта строчка добавляет явную проверку — реализует ли тип MockClient интерфейс Client. Если данный тип не соответствует спецификации интерфейса, код не скомпилируется. Такая конструкция позволяет сделать проверку до того, как появится код, использующий этот тип.
```


### Интерфейсы должны быть компактными

В Go принято делать интерфейсы по возможности маленькими. Чем проще интерфейс, тем легче воспринимать код. Если в интерфейсе больше 5–10 методов, значит, пора его делить.

Хорошая практика — объявлять интерфейс даже с одним методом. Часто такие интерфейсы называют по имени метода и добавляют суффикс -er.

```
type Stringer interface {
    String() string
}
```


### Композиция интерфейсов

В описании интерфейса можно не только перечислять методы, но и встраивать уже существующие интерфейсы — их можно комбинировать:
```
type Reader interface {
    Read(p []byte) (n int, err error)
}

type Writer interface {
    Write(p []byte) (n int, err error)
}

type FileHandle interface {
    Reader
    Writer
    Close() error
}
```

В итоге интерфейс FileHandle будет содержать три метода: Read, Write и Close.

Композиция интерфейсов — очень важная и удобная в применении вещь. Она позволяет встроить в интерфейс требования другого интерфейса, включая интерфейсы из других пакетов. Например, если компания планирует отправлять всех своих сотрудников на обучение, то она может просто встроить интерфейс Student в интерфейс Worker.  Компания может не знать, какие требования задаёт интерфейс Student, но перекладывает ответственность за это на сотрудников.


### Ключевые мысли
* Интерфейс — это тип языка Go, который описывает не структуру переменной, а её поведение.
* Реализация интерфейса — это создание такого типа, который реализует поведение, описанное интерфейсом.
* Переменной типа интерфейс может быть присвоен объект любого типа, если он удовлетворяет этому интерфейсу.
* С точки зрения языка типы T и *T — разные.
* Интерфейс описывается в том же пакете, в котором применяется, и является частью его контракта для внешних пакетов, которые его реализуют.
* Интерфейсы позволяют снизить связность кода.
* Интерфейсы позволяют реализовать полиморфизм и сокрытие в парадигме ООП.
* Интерфейсы можно комбинировать.
* Можно писать свои интерфейсы и к библиотечному коду.


## Интерфейсы в стандартной библиотеке

В предыдущем уроке вы познакомились с интерфейсами в Go. Среди них были Stringer, Reader и Writer, уже находящиеся в стандартной библиотеке, поэтому в продакшен-код их достаточно импортировать, чтобы не писать с нуля. О других популярных интерфейсах из стандартной библиотеки расскажем ниже.

### fmt.Stringer

```
type Stringer interface {
    String() string
}
```

Этот интерфейс часто используется, когда нужно одной строчкой залогировать сложный объект. Определение интерфейса лежит в пакете fmt.

Для примера возьмём структуру User и допишем к ней реализацию интерфейса fmt.Stringer:

```
type User struct {
    Email        string
    PasswordHash string
    LastAccess   time.Time
}

func (u User) String() string {
    return "user with email " + u.Email
}

func main() {
    u := User{Email: "example@yandex.ru"}
    fmt.Printf("Hello, %s", u)
}

// Hello, user with email example@yandex.ru 
```

Функция fmt.Printf использовала реализацию интерфейса. 


### Пакет io

Пакет io предназначен для реализации средств ввода-вывода, однако в нём есть несколько удобных интерфейсов, которые применяются и для других целей.

### io.Reader

```
type Reader interface {
    Read(p []byte) (n int, err error)
}
```

Этот интерфейс описывает чтение из любого потока данных: сети, файловой системы или буфера. Определение интерфейса лежит в пакете io.

Метод Read считывает в переданный слайс байт данные из источника. В качестве источника могут выступать любые данные, которые описаны в типе. То есть считываем их структуры и записываем в байты. Количество считанных байт неявно задаётся размером буфера — длиной слайса. 

Объясним возможности интерфейса на примере. Есть буфер — и нужно прочитать байты из него. В пакете strings лежит функция strings.NewReader, которая оборачивает обычную строку в структуру strings.Reader. Эта структура имеет метод Read, значит, она реализует интерфейс io.Reader:

```
s := `Hodor. Hodor hodor, hodor. Hodor hodor hodor hodor hodor. Hodor. Hodor! 
Hodor hodor, hodor; hodor hodor hodor. Hodor. Hodor hodor; hodor hodor - hodor, 
hodor, hodor hodor. Hodor, hodor. Hodor. Hodor, hodor hodor hodor; hodor hodor; 
hodor hodor hodor! Hodor hodor HODOR! Hodor hodor... Hodor hodor hodor...`

// обернём строчку в strings.Reader
r := strings.NewReader(s)

// создадим буфер на 16 байт
b := make([]byte, 16)

for {
    // strings.Reader скопирует 16 байт в b
    //
    // в структуре запоминается последний указатель,  
    // то есть следующий вызов скопирует следующую порцию из 16 байт
    //
    // также метод возвращает количество прочитанных байт n и ошибку err
    //
    // когда дойдём до конца строки, метод отдаст ошибку io.EOF
    n, err := r.Read(b)

    // при работе с интерфейсом io.Reader нужно в первую очередь проверять
    // n > 0, затем err != nil
    //
    // могут быть ситуации, когда часть данных получилось прочитать
    // и сохранить в буфер, а затем произошла ошибка 
    //
    // в таком случае будут одновременно n > 0 и err != nil
    if n > 0 {
        // выведем на экран содержимое буфера
        fmt.Printf("%v\n", b)
    }

    if err != nil {
        // если дочитали до конца, выходим из цикла
        if errors.Is(err, io.EOF) {
            break
        }

        // обрабатываем ошибку чтения
        fmt.Printf("error: %v\n", err)
    }
}
```

Удобство применения io.Reader в том, что его пользователь может вообще не знать, откуда берутся данные: из файла, сети или генерируются на лету. Интерфейс описывает унифицированный метод работы с ними.

Для закрепления реализуем генератор случайных данных:

```
package randbyte

import (
    "io"
    "math/rand"
)

type generator struct {
    rnd rand.Source // Генератор случайных чисел. Вообще rand.Rand уже реализует интерфейс io.Reader, но для примера мы реализуем его самостоятельно.
}

// New — обратите внимание, что мы возвращаем generator, присвоенный интерфейсу io.Reader, сама структура generator неэкспортируемая.
// Мы скрыли внутри пакета все детали.
func New(seed int64) io.Reader {
    return &generator{
        rnd: rand.NewSource(seed),
    }
}

// Read — реализация io.Reader
func (g *generator) Read(bytes []byte) (n int, err error) { // error — это тип ошибки, подробнее мы рассмотрим его в следующем разделе.
    for i := range bytes {
        randInt := g.rnd.Int63()  // функция возвращает положительное число в пределах от 0 до 2^63
        randByte := byte(randInt) // приводим к типу byte
        bytes[i] = randByte
    }
    return len(bytes), nil
}
```
```
package main

import (
    "example/randbyte"
    "fmt"
    "time"
)

func main() {

    // создаём генератор случайных чисел
    generator := randbyte.New(time.Now().UnixNano()) // в качестве затравки передаём ему текущее время, и при каждом запуске оно будет разным.

    buf := make([]byte, 16)

    for i := 0; i < 5; i++ {
        n, _ := generator.Read(buf) // единственный доступный метод, но он нам и нужен.
        fmt.Printf("Generate bytes: %v size(%d)\n", buf, n)
    }

}
```
Мы реализовали простой генератор случайных байт. 

В последнем рассмотренном примере реализация функции Read не очень эффективна — генератор случайных чисел возвращает 64-битное число, то есть 8 байт. Из них используем только 1.

Попробуйте реализовать более эффективное решение. Для упрощения примера считайте, что функция будет принимать только слайсы, длина которых кратна 8. Для преобразования числа в слайс байт можно использовать функцию из стандартной библиотеки binary.LittleEndian.PutUint64([ ]byte, uint64).

```
// Read — реализация io.Reader
func (g *generator) Read(bytes []byte) (n int, err error) { // error это тип ошибки, подробнее мы рассмотрим его в следующем разделе.
    for i := 0; i+8 < len(bytes); i += 8 {
        binary.LittleEndian.PutUint64(bytes[i:i+8], uint64(g.rnd.Int63()))
    }
    return len(bytes), nil
}
```


### io.Writer

```
type Writer interface {
    Write(p []byte) (n int, err error)
} 
```

Этот интерфейс означает запись в любой возможный поток данных: сетевой сокет, файл или буфер. Определение интерфейса лежит в пакете io.

C этим интерфейсом ситуация, обратная io.Reader. Он позволяет записать переданный ему слайс байт куда-то. Куда именно — определяется реализацией.

Для примера соберём большую строку из подстрок, вот только не через оператор +=, потому что тогда на каждую итерацию будет лишняя копия всей строки. В пакете strings есть структура strings.Builder для сборки строки без избыточного копирования. Эта структура имеет метод Write, значит, она реализует интерфейс io.Writer:

```
// создаём strings.Builder
w := strings.Builder{}

for i := 0; i < 50; i++ {
    // функция fmt.Fprintf принимает аргументом io.Writer
    // благодаря этому можно записывать форматированный вывод
    fmt.Fprintf(&w, "%v", math.NaN())
}

w.Write([]byte("... BATMAN!"))

// выводим собранную строку
fmt.Printf("%s\n", &w)
```

Приведём пример реализации интерфейса Write. Предположим, что мы хотим посчитать хеш от некоторого массива байт или наборов массивов. Для простоты возьмём упрощённую функцию хеширования:
```
package hashbyte

import "io"

type Hasher interface {
    io.Writer // мы встроили интерфейс io.Writer в наш интерфейс, чтобы задать требование по наличию метода Write
    Hash() byte
}

type hash struct {
    result byte
}

func New(_init byte) Hasher {
    return &hash{
        result: _init,
    }
}

// Write — сюда может быть записан массив байт любой длины, для которой будет подсчитываться хэш.
func (h *hash) Write(bytes []byte) (n int, err error) {
    // обновляем хеш для каждого байта, записанного в хешер
    for _, b := range bytes {
        h.result = (h.result^b)<<1 + b%2 
    }
    return len(bytes), nil
}

func (h hash) Hash() byte {
    return h.result
}
```

Теперь используем её в нашей программе: 
```
func main() {

    // создаём генератор случайных чисел
    generator := randbyte.New(time.Now().UnixNano()) // в качестве затравки передаём ему текущее время — при каждом запуске оно будет разным

    buf := make([]byte, 16)

    for i := 0; i < 5; i++ {
        n, _ := generator.Read(buf)
        fmt.Printf("Generate bytes: %v size(%d)\n", buf, n)
    }

    hasher := hashbyte.New(0)
    hasher.Write(buf)
    fmt.Printf("Hash: %v \n", hasher.Hash())

}
```


### Функции-утилиты для io.Reader и io.Writer

### io.Copy

> func Copy(dst Writer, src Reader) (written int64, err error)

Функция копирует все байты из io.Reader в io.Writer.

Данные будут считываться до тех пор, пока функция Read не вернёт вторым аргументом ошибку. Если в качестве ошибки будет возвращено значение io.EOF, то выполнение функции закончится без ошибок. Также будет возвращено количество байт. 

io.EOF происходит от end of frame (конец файла) — исторически так назывался специальный символ, который означал конец файла. 

Приведём простой пример. Напишем функцию, копирующую содержимое одного файла в другой:

```

func CopyFile(srcFileName, dstFileName string) error {
    srcFile, err := os.Open(srcFileName)
    if err != nil {
        return err
    }
    dstFile, err := os.Create(dstFileName)
    if err != nil {
        return err
    }
    n, err := io.Copy(dstFile, srcFile)
    if err != nil {
        return err
    }
    fmt.Printf("Copied %d bytes from %s to %s", n, srcFileName, dstFileName)
    return nil
}
```

Структура типа os.File реализует интерфейсы io.Reader и io.Writer. 

Было бы просто считать весь исходный файл в память и затем скопировать его в новый. Но если исходный файл занимает сотни гигабайт? io.Copy работает умнее, считывая и записывая данные небольшими кусочками, поэтому для подобных операций рекомендуется использовать именно её.


### io.CopyN

> func CopyN(dst Writer, src Reader, n int64) (written int64, err error) 

Функция копирует все байты из io.Reader в io.Writer, но не более n байт. То же самое, что и Copy, но с ограничением — можно использовать с источниками данных, которые слишком большие или вообще бесконечные. Например, напишем функцию, которая будет сохранять данные из нашего генератора случайных чисел в файл.

```
// Dump — сохраняет вычисленные данные в файл
func (g generator) Dump(n int64, dst *os.File) error {
    _, err := io.CopyN(g, dst, n)
    return err
}
```

Если бы мы использовали Copy, то программа продолжила бы работать до переполнения диска. 


### io.ReadAll

> func ReadAll(r Reader) ([]byte, error) 

Функция считывает все байты из io.Reader. Чтение закончится, когда io.Reader вернёт io.EOF. 


### io.ReadAtLeast

> func ReadAtLeast(r Reader, buf []byte, min int) (n int, err error) 

Функция считывает байты из io.Reader c ограничением: если прочитанных байт оказалось меньше, чем n, вернётся ошибка io.ErrUnexpectedEOF. Это используется при парсинге бинарных данных, чтобы гарантировать, что нужное минимальное количество байт будет вычитано.


### Другие интерфейсы пакета io

Мы привели примеры основных методов работы с функциями и интерфейсами ввода-вывода. Кроме них, в пакете осталось ещё много интересного. Рекомендуем открыть документацию пакета io, чтобы посмотреть на определения остальных интерфейсов. io.Reader и io.Writer — основные интерфейсы, но могут пригодиться и другие.


В пакете io есть функция LimitReader(r io.Reader, n int64) io.Reader. Она ограничивает количество байт, которое можно вычитать из io.Reader. 
```
package main

import (
    "io"
    "log"
    "os"
    "strings"
)

type LimitedReader struct {
    reader io.Reader
    //  запоминаем количество считанных байт
    left   int
}

func LimitReader(r io.Reader, n int) io.Reader {
    return &LimitedReader{reader: r, left: n}
}

func (r *LimitedReader) Read(p []byte) (int, error) {
    if r.left == 0 {
        return 0, io.EOF
    }
    if r.left < len(p) {
        p = p[0:r.left]
    }
    n, err := r.reader.Read(p)
    r.left -= n
    return n, err
}

func main() {
    r := strings.NewReader("some io.Reader stream to be read\n")
    lr := LimitReader(r, 4)

    _, err := io.Copy(os.Stdout, lr)
    if err != nil {
        log.Fatal(err)
    }
}
```


## Пустой интерфейс и приведение типов

В предыдущих уроках в определениях функций и структур использовались интерфейсы. Но бывают ситуации, когда не всегда можно указать конкретные типы переменных. Например, если получаем JSON-документ от пользователя, то структура этого документа может быть любой. 

Разрешить функции принимать произвольный параметр можно с помощью **пустого интерфейса** — интерфейса без методов.

Действительно, так как интерфейс является набором требований к типу, то пустой интерфейс ничего от типа не требует. Он может быть чем угодно. Однако и использовать переменную типа пустого интерфейса невозможно.

```
func PassAnyType(v interface{}) {
    // ...
}
```

***В Go 1.18 у типа interface{} появился более короткий и понятный псевдоним any (от англ. any — любой).***

Но с переменной v нельзя ничего сделать. Нужно привести её к определённому типу оператором v.(Тип). 

Оператор приведения типа приводит переменную интерфейсного типа к конкретному типу или другому интерфейсу.  

```
func PassAnyType(v interface{}) {
    i := v.(int)     // если v не число, то будет паника, то есть программа не сможет работать и прекратит выполнение

    i, ok := v.(int) // альтернативный формат: если v не число, то будет false
                     // паники не будет 
    if ok {
        // ...
    }
}
```

Второй вариант использования более предпочтителен.

Оператором switch можно лаконично запрограммировать логику относительно каждой проверки типа. Для примера напишем свою реализацию функции fmt.Printf:

```
func Printf(v interface{}) {
    switch v2 := v.(type) {
    case int:
        fmt.Print("Это число " + strconv.FormatInt(v2, 10))
    case string:
        fmt.Print("Это строка " + v2)
    case Stringer:
        fmt.Print("Это тип, реализующий Stringer, " + v2.String())
    default:
        fmt.Print("Неизвестный тип")
    }
}
```

Попробуйте реализовать обобщение операции умножения для чисел и строк. Если первый аргумент функции — строка, то повторить её b раз, а если число, то вернуть a*b. 
```
func Mul(a interface{}, b int) interface{} {
    switch va := a.(type) {
    case int:
        return va * b
    case string:
        return strings.Repeat(va, b)
    case fmt.Stringer:
        return strings.Repeat(va.String(), b)
    default :
        return nil
    }
}
```


### Внутреннее устройство интерфейсов

Чтобы понять, каким образом интерфейсы приводятся к другим типам, следует разобраться, как устроен интерфейс изнутри.

Соединим примеры из предыдущего и текущего уроков:
```
type User struct {
    Email      string
    Password   string
    LastAccess time.Time
}

func (u User) String() string {
    return "user with email " + u.Email
}

func Printf(v Stringer) {
    fmt.Print("Это тип, реализующий Stringer, " + v.String())
}

func main() {
    u := User{Email: "example@yandex.ru"}
    Printf(u)
}
```

Вот какие данные будут храниться в переменной v Stringer:

<img src="https://pictures.s3.yandex.net/resources/8.3._1643217711.png">

На схеме видно, что интерфейс состоит из двух указателей: на метаданные типа и на сами данные. При приведении типа используются эти метаданные, чтобы вычислить, какой конкретный тип представляет этот интерфейс и как правильно разыменовать указатель на данные.

Почему так устроено? Всё дело в том, что переменной интерфейсного типа могут быть присвоены данные разного размера. Например, интерфейсу Stringer может удовлетворять и большая сложная структура, и пользовательский int. Поэтому сохраняем данные по указателю. А вот в itable храним метаинформацию о типе, который там содержится.

Когда присваиваем переменную конкретного типа, происходит следующее:

```
// Компилятор создаёт в программе метаданные со списком методов интерфейса
type Stringer interface {
    String() string
}

// Компилятор создаёт в памяти структуру с описанием типа User, его полей
type User struct {
    
} 

var user Stringer // Объявляется переменная интерфейса — её значение пока что равно nil, в памяти выделяется два машинных слова под указатели tab и data  

// Переменной присваивается конкретное значение. Проверяется, удовлетворяет ли тип переменной интерфейсу. 
// При этом в tab записывается указатель на структуру itable, связывающий информацию о типе User и Stringer,
// а в data — указатель на User{}
user := User{}

// Интересно, что связывание типа и интерфейса происходит не на этапе компиляции, иначе размер программы был бы слишком большим, а на этапе выполнения. Эта операция кешируется, так что выполняется всего один раз и не влияет на производительность.

// Проверяем, что в tab у нас лежит действительно тип User — и если да, то ok true, а в переменную u копируется значение data.   
// Если типы не совпадают, то ok — false
u, ok := user.(User)
```

***Интерфейсная переменная по природе относится к ссылочному типу. Если передать её в функцию, то она скопируется, но, так как указатели будут указывать на ту же исходную переменную, изменение переменной через вызов методов может изменить данные. ***

В Go есть особенность, связанная с nil. Посмотрите ещё раз на схему: интерфейс может быть nil, а может быть с nil-указателем на данные. Покажем пример, где эта особенность приводит к ошибке:

```
// Собственный тип для ошибок. Аналогичен стандартному error
type Error interface {
    Error() string
}

// MyError — структура, реализующая нашу ошибку
type MyError struct {
    // ...
}

// Error — метод для удовлетворения интерфейсу Error
func (e *MyError) Error() string {
    return "..."
}


// переменная типа ошибки — указатель на пустую структуру
var ErrFriday13 = &MyError{}

func CheckTodayIsOkay() Error {
    var err *MyError // указатель на переменную типа Error
    // получаем текущее время
    t := time.Now()
    // если день недели пятница и число месяца 13, то вернём ошибку  
    if t.Weekday() == time.Friday && t.Day() == 13 {
        err = ErrFriday13
    }
    // вернём ошибку ... указатель же nil
    return err
}

func main() {
    err := CheckTodayIsOkay()
    // проверяем err на nil — и внезапно всегда не nil 
    if err != nil {
        fmt.Println("error is not nil")
        return
    }

    fmt.Println("error is nil")
}
```

Код выведет строчку "error is not nil", потому что Go обернёт nil-указатель *MyError в не-nil-интерфейс Error.
То есть мы присвоили переменной типа interface{} переменную определённого типа. Это значит, что метаданные непустые. Исправить проблему можно так:
```
func CheckTodayIsOkay() Error {
    var err Error

    t := time.Now()
    if t.Weekday() == time.Friday && t.Day() == 13 {
        err = ErrFriday13
    }

    return err
}
```

В этом случае код выведет строчку "error is nil", потому что сам интерфейс Error будет nil.


### Сравнение интерфейсов

Сравнение интерфейсных типов имеет одну особенность, которую важно знать, так как она может привести к неочевидным ошибкам. Рассмотрим следующий пример:

```
type Stringer interface {
    String string
}

// создадим свой собственный тип на основе map 
type MyMap map[string]string

func (m MyMap) String () string {
    return fmt.Sprintf("%v", m)
}

// И ещё один тип на основе int
type MyInt int

func (m MyInt) String () string {
    return fmt.Sprintf("%v", m)
}

func main () {
    var mm MyMap
    var mi MyInt
    
    mm = MyMap{}
    mi = MyInt(5)
    
    fmt.Println(mm == mi) // false 
    fmt.Println(mm == mm) // Паника!
}
```

На первый взгляд, в программе творится нечто странное: с одной стороны, мы сравнили без ошибок мапу и целое, с другой — получили ошибку при сравнении переменной с самой собой.

Всё дело в том, что интерфейсы сравниваются по цепочке. Сначала сравнивается тип: если типы переменных внутри разные, то вернётся false; если одинаковые, то сравниваются уже сами данные. А map сравнивать между собой нельзя, и получаем панику.
