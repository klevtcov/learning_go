## Является ли Go языком ООП?

* https://habr.com/ru/post/225907/
* Автор - https://habr.com/ru/users/Xlab/

<img src="https://habrastorage.org/r/w1560/getpro/habr/post_images/72a/bbe/3ac/72abbe3acdc6311040c12b068fb8b95b.png"  width=15% />

Предлагаю вашему вниманию вольный перевод заметки «Is Go An Object Oriented Language?» за авторством Steve Francia, в которой автор наглядно рассказывает об особенностях использования парадигмы ООП в Go. Сразу предупреждаю, что из-за свойств оригинального материала большую часть текста пришлось переформулировать полностью, где-то добавить своего. Флажок перевода убирать не стал.

1. **Введение**

Так что же это значит, быть «объектно-ориентированным»? Обратимся к истории возникновения концепта ООП, попробуем разобраться.
Первый объектно-ориентированный язык, Simula, появился на горизонте в 60-x годах. Он привнёс понятия объектов, классов, понятия наследования и классов-потомков, виртуальных методов, сопрограмм и многое другое. Походу, самым ценным вкладом стала парадигма абстракции данных.

Вы можете быть не знакомы со Simula, но, вне всяких сомнений, точно знаете некоторые из тех языков, для которых он стал вдохновением — Java, C++, C# и Smalltalk, которые позже, в свою очередь, сильно повлияли на Objective-C, Python, Ruby, Javascript, Scala, PHP, Perl… полный перечень содержит почти все популярные современные языки. Эта парадигма настолько прочно вошла в нашу жизнь, что большинство современных программистов никогда и не думали иначе.

Поскольку общепринятого определения ООП не существует, для продолжения дискуссии мы сформулируем своё. 

<code>Вместо явного разделения кода и данных в тексте программы, объектно-ориентированная система объединяет их используя концепцию «объекта». Объектом называется абстрактный тип данных, включающий состояние (данные) и поведение (код).
</code>  

Поскольку изначальная реализация имела механизмы наследования и полиморфизма, которые были переняты практически во всех производных языках, определения объектно-ориентированного программирования обычно включают их как необходимое условие.

Далее мы рассмотрим, как в Go используются объекты, полиморфизм и наследование, после чего будет проще ответить на поставленный вопрос.

2. **Объекты?**

В Go нет ничего с именем object, хотя это и не важно. Пусть тип object не встречается, зато есть тип, попадающий под определение объектно-ориентированного подхода — структуры данных, включающие и состояние и поведение, они обозначаются как struct. struct это тип, содержащий именованные поля и методы.

Для наглядности приведу пример:
```
type rect struct {
    width int
    height int
}

func (r *rect) area() int {
    return r.width * r.height
}

func main() {
    r := rect{width: 10, height: 5}
    fmt.Println("area: ", r.area())
}
```

Первый блок определяет новый тип rect структурного типа, содержащего 2 целочисленных поля. Следующий блок определяет метод на этой структуре путём определения функции area и прикрепления её к типу rect. Точнее, на самом деле функция прикрепляется к типу-указателю на rect.
Последний блок является точкой входа программы, это функция main. Первая строка создаёт новый экземпляр rect (выбранный способ создания экземпляра — через составной литерал — является наиболее удобным в Go). Вторая строчка отвечает за вывод результатов вызова функции area на значении r.

Лично мне это всё сильно напомнило работу с объектами. Я могу создать тип структурированных данных и определить методы для работы с некоторыми из них.
Чего-то ещё не хватает? Да, в большинстве объектно-ориентированных языков для описания объектов используются классы с поддержкой наследования, причём хорошей практикой считается определение интерфейсов для этих классов и тем самым определение дерева иерархии классов (в случае простого наследования).

  2 **Наследование и полиморфизм**

Существует несколько различных подходов к определению отношений между объектами. И хотя имеются некоторые различия, все они используются практически с одной целью — ради повторного использования кода.

 2.1 **Простое и множественное наследование**

Наследование это механизм языка, позволяющий описать новый класс на основе уже существующего (базового) класса. Существует две разновидности наследования, на основании количества базовых классов. Принципиальную разницу можно ощутить лишь оценивая последствия применения множественного наследования: иерархия простого наследования (single inheritance) представляет собой дерево, в то время как множественное наследование порождает решётку. Языки с поддержкой исключительно простого включают PHP, C#, Java и Ruby, а к языкам с поддержкой множественного наследования относятся Perl, Python и C++.

  2.2. **Полиморфизм подтипов**

В некоторых языках понятия подтипов и наследования так тесно переплетены, что разница между ними едва заметна. На самом деле подтипы определяют семантические отношения между двумя и более объектами, тем самым образуя отношения is-a. То есть, тип A является подтипом B тогда, когда спецификация A следует из спецификации B и любой удовлетворяющий спецификации A объект (или класс) также удовлетворяет спецификации B. В то время как простое наследование только повторно использует реализацию, тем самым обеспечивая синтаксический сахар, но не более.

Следует чётко различать наследование через реализацию и «наследование» через полиморфизм подтипов, что будет понятно из текста далее.

  2.3. **Композиция**
При композиции один объект определяется путём включения в него других объектов, то есть вместо наследования он просто содержит их. Такой тип взаимосвязи называется has-a и включаемые объекты подчиняются правилам принадлежности.

3. **Есть ли в Go наследование?**

Go по задумке был спроектирован без наследования в обычном понимании этого слова. Вовсе не значит, что объекты (структуры) не имеют отношений, просто авторы языка выбрали иной механизм обозначения таковых. Для многих начинающих писать на Go это решение может показаться серьёзной недоработкой, однако, в действительности же, это одно из самых приятных свойств языка и оно решает много проблем, заодно закрывая споры вокруг наследования — возраст которых исчисляется десятками лет — раз и навсегда.

4. **«Простое наследование лучше выкинуть»**

Далее я приведу фрагмент из статьи на JavaWorld — «Why extends is evil»:

<code>В книге банды четырёх о паттернах проектирования детально обсуждается замена наследования через реализацию (extends) на наследование через интерфейсы (implements).

Я однажды посетил сходку юзер группы Java, куда James Gosling (создатель Java) был приглашён делать доклад. Во время памятной сессии вопросов и ответов кто-то спросил его: «Если бы вы могли сделать Java заново, что бы вы изменили?». «Я бы выкинул классы», ответил он. После того как смех в зале утих, он объяснил, что настоящая проблема заключается не в классах по сути, а в наследовании через реализацию (отношение extends). Наследование же через интерфейсы (отношение implements) является предпочтительным, следует избегать наследование через реализацию там, где возможно.</code>  

5. **Отношения объектов в Go**

  5.1. **Композиция типов**

Вместо обычного наследования в Go строго используется принцип композиции вместо наследования и отношения между структурами и интерфейсами строятся по принципам is-a и has-a. Используемый здесь механизм композиции объектов представляется встраиваемыми типами, так, Go позволяет встроить структуру в структуру, создавая при этом отношения типа has-a. Хорошим примером является связь между типами Person и Address в коде ниже:
```
type Person struct {
   Name string
   Address Address
}

type Address struct {
   Number string
   Street string
   City   string
   State  string
   Zip    string
}

func (p *Person) Talk() {
    fmt.Println("Hi, my name is", p.Name)
}

func (p *Person) Location() {
    fmt.Println("Im at", p.Address.Number, p.Address.Street, p.Address.City, p.Address.State, p.Address.Zip)
}

func main() {
    p := Person{Name: "Steve"}
    p.Address = Address{ Number: "13", Street: "Main" }
    p.Address.City = "Gotham"
    p.Address.State = "NY"
    p.Address.Zip = "01313"
    p.Talk()
    p.Location()
}
```

Результат:
```
>  Hi, my name is Steve
>  Im at 13 Main Gotham NY 01313
```
> play.golang.org/p/5TVBDR7AYo