### Структуры

+ Структура — это тип, содержащий именованные поля. Например, мы можем представить круг таким образом:
```
type Circle struct {
    x float64
    y float64
    r float64
}
```
Как и с функциями, мы можем объединять поля одного типа:
```
type Circle struct {
    x, y, r float64
}
```
+ Инициализация
```
var c Circle
// или
c := Circle{}
```
> c := new(Circle)
Это выделит память для всех полей, присвоит каждому из них нулевое значение и вернет указатель (*Circle).
Часто, при создании структуры мы хотим присвоить полям структуры какие-нибудь значения.
> c := Circle{x: 0, y: 0, r: 5} // с именами полей
> c := Circle{0, 0, 5} // по порядку полей

+ Поля
Получить доступ к полям можно с помощью оператора . (точка)
```
fmt.Println(c.x, c.y, c.r)
c.x = 10
c.y = 5
```
Давайте изменим функцию circleArea так, чтобы она использовала структуру Circle:
```
func circleArea(c Circle) float64 {
    return math.Pi * c.r * c.r
}
```
```
c := Circle{0, 0, 5}
fmt.Println(circleArea(c))
```
Очень важно помнить о том, что аргументы в Go всегда копируются. Если мы попытаемся изменить любое поле в функции circleArea, оригинальная переменная не изменится. Именно поэтому мы будем писать функции используя указатели:
```
func circleArea(c *Circle) float64 {
    return math.Pi * c.r * c.r
}
```
И изменим main:
```
c := Circle{0, 0, 5}
fmt.Println(circleArea(&c))
```

### Методы
+ метод — функция особого типа
```
func (c *Circle) area() float64 {
    return math.Pi * c.r * c.r
}
```
Между ключевым словом func и именем функции мы добавили «получателя». Получатель похож на параметр — у него есть имя и тип, но объявление функции таким способом позволяет нам вызывать функцию с помощью оператора .:
> fmt.Println(c.area())

### Встраиваемые типы
Обычно, поля структур представляют отношения принадлежности (включения). Например, у Circle (круга) есть radius (радиус). Предположим, у нас есть структура Person (личность):
```
type Android struct {
    Person
    Model string
}
```
И если мы хотим создать новую структуру Android, то можем сделать так:
```
type Android struct {
    Person Person
    Model string
}
```
Это будет работать, но мы можем захотеть создать другое отношение. Сейчас у андроида «есть» личность, можем ли мы описать отношение андроид «является» личностью? Go поддерживает подобные отношения с помощью встраиваемых типов, также называемых анонимными полями. Выглядят они так:
```
type Android struct {
    Person
    Model string
}
```
Мы использовали тип (Person) и не написали его имя. Объявленная таким способом структура доступна через имя типа:
```
a := new(Android)
a.Person.Talk()
```
Но мы также можем вызвать любой метод Person прямо из Android:
```
a := new(Android)
a.Talk()
```
Это отношение работает достаточно интуитивно: личности могут говорить, андроид это личность, значит андроид может говорить.

Также мы можем при создании инициализировать нужные переменные:
```
var a = Android{
	Model: "model",
	Person: Person {
		Name: "name",
	},
}
```

