## Обработка ошибок

Хороший код должен правильно реагировать на непредвиденные обстоятельства, такие как ввод некорректных данных пользователем, разрыв сетевого подключения или отказ дисков. Обработка ошибок — это процесс обнаружения ситуаций, когда ваша программа находится в неожиданном состоянии, а также принятие мер для записи диагностической информации, которая будет полезна при последующей отладке.

В отличие от других языков программирования, где разработчикам нужно обрабатывать ошибки с помощью специального синтаксиса (try catch/try except), ошибки в Go — это значения с типом error, возвращаемые функциями, как и любые другие значения. Для обработки ошибок в Go мы должны проверить ошибки, которые могут возвращать функции, решить, существует ли ошибка, а также принять надлежащие меры для защиты данных и сообщить пользователям или операторам, что произошла ошибка.

Самая простая обработка - это проверка ошибки на пустоту. Многие методы и функции в GO при вызове возвращают не только нужный результат, но и ошибку. К примеру: у нас есть функция которая делит число на другое число и ввод переменной.
```
package main

import "fmt"

func divide(a int, b int) int {
	return a / b
}

func main() {
	var input int
	_, err := fmt.Scan(&input) // функция Scan возвращает два параметра, но нам сейчас важно проверить только ошибку
	if err != nil {
		fmt.Println("Проверьте типы входных параметров")
	} else {
		fmt.Println(divide(input, 5)) //Выведем результат, если ошибок нет
	}
}
```

### Создание ошибок
Стандартная библиотека предоставляет две встроенные функции для создания ошибок: errors.New и fmt.Errorf. Обе эти функции позволяют нам указывать настраиваемое сообщение об ошибке, которое вы можете отображать вашим пользователям.

errors.New получает один аргумент — сообщение об ошибке в виде строки, которую вы можете настроить, чтобы предупредить ваших пользователей о том, что пошло не так.

Попробуйте запустить следующий пример, чтобы увидеть ошибку, созданную с помощью errors.New, которая выполняет стандартный вывод:
```
package main

import (
    "errors"
    "fmt"
)

func main() {
    err := errors.New("my error")
    fmt.Println("", err)
}
```

Мы использовали функцию errors.New из стандартной библиотеки для создания нового сообщения об ошибке со строкой "barnacles" в качестве сообщения об ошибке. Мы выполняли требование конвенции, используя строчные буквы для сообщения об ошибке, как показано в руководстве по стилю для языка программирования Go.
+ https://github.com/golang/go/wiki/CodeReviewComments#error-strings

### Оператор panic
Оператор panic позволяет сгенерировать ошибку и выйти из программы:
```
package main
import "fmt"
 
func main() {
    fmt.Println(divide(15, 5))
    fmt.Println(divide(4, 0))
    fmt.Println("Program has been finished")
}
func divide(x, y float64) float64{
    if y == 0{ 
        panic("division by zero!")
    }
    return x / y
}
```
Оператору panic мы можем передать любое сообщение, которое будет выводиться на консоль. Например, в данном случае в функции divide, если второй параметр равен 0, то осуществляется вызов panic("division by zero!").

В функции main в вызове fmt.Println(divide(4, 0)) будет выполняться оператор panic, поскольку второй параметр функции divide равен 0. И в этом случае все последующие операции, которые идут после этого вызова, например, в данном случае это вызов fmt.Println("Program has been finished"), не будут выполняться. В этом случае мы получим следующий консольный вывод:
```
3
panic: division by zero!
```
И в конце вывода будет идти диагностическая информация о том, где возникла ошибка.

### В чем преимущество значений ошибок Go по сравнению с исключениями?
Go подталкивает разработчиков к тому, чтобы они поняли причину ошибок, что приводит к более понятным программам, в то время как исключения обычно игнорируются по умолчанию. Значения ошибок не требуют специальных ключевых слов, делая их более простыми и в то же время гибкими.

+ https://blog.golang.org/defer-panic-and-recover

## Оператор defer
Оператор defer позволяет выполнить определенную операцию после каких-то действий (даже если сработает panic), при этом не важно, где в реальности вызывается эта функция. Например:
```
package main
import "fmt"
 
func main() {
    defer finish()
    fmt.Println("Program has been started")
    fmt.Println("Program is working")
}
 
func finish(){
    fmt.Println("Program has been finished")
}
```
Здесь функция finish вызывается с оператором defer, поэтому данная функция в реальности будет вызываться в самом конце выполнения программы, несмотря на то, что ее вызов определен в начале функции main. В частности, мы получим следующий консольный вывод:
```
Program has been started
Program is working
Program has been finished
```
Если несколько функций вызываются с оператором defer, то те функции, которые вызываются раньше, будут выполняться позже всех. Например:
```
package main
import  "fmt"
 
func main() {
      
    defer finish()
    defer fmt.Println("Program has been started")
    fmt.Println("Program is working")
}
 
func finish(){
    fmt.Println("Program has been finished")
}
```
Консольный вывод:
```
Program is working
Program has been started
Program has been finished
```
Дополнение: команда defer помещает вызов функции в стек. Поэтому они выполняются в очередности -LIFO (Last-In, First-Out)

defer запоминает значения переменных, переданных в функцию, на момент объявления defer, а не на момент его вызова. То есть условно
```
a:=5
defer myFunc(a) // когда вызовется myFunc - будет передано значение 5, а не 7
a = 7
```

Оператор defer позволяет выполнить определенную функцию перед выходом из функции

Например. Открыли файл, можно написать defer file.close() и  быть уверенным что файл будет закрыт, даже если до конца функции мы не добрались и возвратили ошибку по каким-то причинам.

### Продвинутая работа с ошибками и паникой в Go (Golang)
Мы познакомились с ошибками в Go, но за девять небольших шагов полностью покрыть эту тему невозможно.

Кому интересно

* преисполниться философией Go относительно ошибок;
* узнать, как создавать ошибки стандартными и нестандартными способами;
* разобрать понятие врапинга ошибок;
* понять, какие ошибки можно игнорировать, а какие нет;
* не бояться словосочетаний sentinel errors, opaque errors, error types и constant errors;
* сделать свой код по работе с ошибками production ready;
* узнать, когда можно паниковать, а когда нет;
* как паника выглядит под капотом;
* какие подводные камни спрятаны за связкой defer, panic и recover;
* порешать более 200 заданий и тестов на эту и смежные темы;
* и многое другое
Мы приглашаем на специализацию Продвинутая работа с ошибками и паникой в Go (Golang), состояющую из двух частей:
+ https://stepik.org/z/114432?utm_source=go_prog&utm_medium=referral&utm_campaign=general (30к рублей)

* Продвинутая работа с ошибками в Go (Golang) – https://stepik.org/z/89381?utm_source=go_prog&utm_medium=referral&utm_campaign=general
* Продвинутая работа с паникой в Go (Golang) – https://stepik.org/z/101420?utm_source=go_prog&utm_medium=referral&utm_campaign=general
Тому, кто только начал своё знакомство с Go, программа будет не по зубам. Но если у вас есть опыт программирования в целом, навыки гугления стандартных пакетов и желание дойти до конца – то курсы должны хорошо зайти.

---

Специализация разом гораздо дешевле, чем покупка курсов по отдельности, но если вы захотите сначала попробовать один из них, то промокод GO_PROG_REF даёт 10% скидку на любой из курсов и поддерживает наш бесплатный курс для дальнейшего развития.

До встречи на курсах!