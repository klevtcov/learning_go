### Строки (string)

Строковые литералы могут быть созданы с помощью двойных кавычек "Hello World" или с помощью обратных апострофов `Hello World`. Различие между ними в том, что строки в двойных кавычках позволяют использовать особые управляющие последовательности символов. Например, \n (перенос строки) или \t (символом табуляции).

Строка представляет собой неизменяемую последовательность байтов. Из этого следует ряд выводов:
* к строке применимы операции, применимые к массивам и срезам;
* чтобы изменить строку, необходимо создать новую строку;
* мы можем итерироваться по строке как и по всякой последовательности, но итерируясь по строке, мы будем итерироваться по байтам, составляющим строку, а не по символам;
* мы можем определить в строке подстроку.
```
func ExampleString() {
	// Создадим строковый литерал s, значение которого "Это строка".
	// Строка состоит из 10 символов.
	var s string = "Это строка"

	// Однако длина строки len(s) составит 19 байт, т.к. использованные кирилические символы
	// занимают 2 байта, а пробел занимает 1 байт.
	fmt.Printf("Длина строки: %d байт\n", len(s))

	// Посмотрим как взять подстроку
	fmt.Printf("Напечатаем только второе слово в кавычках: \"%v\"\n", s[7:])

	/*
		Попробуем изменить что-то встроке:
		s[3] = 12
		Ошибка компиляции: cannot assign to s[3], потому что строки - неизменяемые последовательности.
	*/

	// "Изменим строку", создав новую
	s = s + " Новая строка"
	fmt.Printf("%v\n", s)

	// А теперь проитерируемся по этой строке
	for _, b := range s {
		fmt.Printf("%v ", b)
	}
	fmt.Print("\n")

	// Output:
	// Длина строки: 19 байт
	// Напечатаем только второе слово в кавычках: "строка"
	// Это строка Новая строка
	// 1069 1090 1086 32 1089 1090 1088 1086 1082 1072 32 1053 1086 1074 1072 1103 32 1089 1090 1088 1086 1082 1072

}
```
В заключение скажем, что строки поддерживают проверку на равенство и неравенство, а вот проверки <> со строками уже не дадут нужного нам результата, т.к. сравнивать Go будет байты, а не символы, т.е. результат для нас может быть не тот, что мы ожидаем (сравнивается не длина строк):
```
func ExampleEqualString() {
	fmt.Printf("Сравнение на равенство строк \"строка1\" и \"строка2\": %v\n", "строка1" == "строка2")
	fmt.Printf("Сравнение на неравенство строк \"строка1\" и \"строка2\": %v\n", "строка1" != "строка2")

	fmt.Printf("\"Строка1\" > \"Строка2\": %v", "Строка1" > "Строка2")

	// Output:
	// Сравнение на равенство строк "строка1" и "строка2": false
	// Сравнение на неравенство строк "строка1" и "строка2": true
	// "Строка1" > "Строка2": false
}
```
### Функции для работы со строками

Go содержит большое количество функций для работы со строками в пакете strings , кратко рассмотрим основные:
```
func main() {
    fmt.Println(    
        // Содержится ли подстрока в строке    
        strings.Contains("test", "es"), 
        // результат: true

        // Кол-во подстрок в строке
        strings.Count("test", "t"),
        // результат: 2

        // Начинается ли строка с префикса       
        strings.HasPrefix("test", "te"), 
        // результат: true

        // Заканчивается ли строка суффиксом
        strings.HasSuffix("test", "st"), 
        // результат: true

        // Возвращает начальный индекс подстроки в строке, а при отсутствии вхождения возвращает -1
        strings.Index("test", "e"), 
        // результат: 1

        // объединяет массив строк через символ
        strings.Join([]string{"hello","world"}, "-"),
        // результат: "hello-world"

        // Повторяет строку n раз подряд
        strings.Repeat("a", 5), 
        // результат: "aaaaa"

        // Функция Replace заменяет любое вхождение old в вашей строке на new
        // Если значение n равно -1, то будут заменены все вхождения.
        // Общий вид: func Replace(s, old, new string, n int) string
        // Пример:
        strings.Replace("blanotblanot", "not", "***", 	-1),
        // результат: "bla***bla***"
 
        // Разбивает строку согласно разделителю
        strings.Split("a-b-c-d-e", "-"), 
        // результат: []string{"a","b","c","d","e"}

        // Возвращает строку c нижним регистром
        strings.ToLower("TEST"), 
        // результат: "test"

        // Возвращает строку c верхним регистром
        strings.ToUpper("test"), 
        // результат: "TEST"

        // Возвращает строку с вырезанным набором
        strings.Trim("tetstet", "te"),
        // результат: s
    )
```

### Байтовые срезы ([]byte)
Когда мы рассматривали строки, то говорили, что строки - это последовательность байт. Пришло время кратко рассмотреть этот тип данных. Кратко потому, что байтовый срез (последовательность байт) - это изменяемая последовательность чисел (тип byte соответствует типу uint8.), из чего мы делаем следующие выводы:

* байтовый срез можно изменять (в отличие от строки);
* к байтовому срезу применимо все, что применимо к массивам и срезам других типов (взятие среза, итерация);
* к отдельным байтам применимы операции, применимые к числам.
```
func ExampleByteSlice() {
	// Используем тип string, который конвертируем в []byte,
	// чтобы не использовать абстрактные цифры
	bs := []byte("Это байтовый срез")

	fmt.Printf("Так байтовый срез выглядит внутри: %v\n", bs)

	// Продемонстрируем, что байтовый срез можно изменить,
	// а затем напечатаем его в виде строки
	for i := range bs {
		if bs[i]%2 == 0 {
			bs[i] = bs[i] + 1
			continue
		}
		bs[i] = bs[i] - 1
	}

	fmt.Printf("Измененный байтовый срез в виде строки: %s", bs)

	// Output:
	// Так байтовый срез выглядит внутри: [208 173 209 130 208 190 32 208 177 208 176 208 185 209 130 208 190 208 178 209 139 208 185 32 209 129 209 128 208 181 208 183]
	// Измененный байтовый срез в виде строки: ѬЃѿ!ѰѱѸЃѿѳЊѸ!ЀЁѴѶ
}
```
Заканчивая разговор о байтовом срезе нужно сказать, что т.к. этот тип может хранить фактически любые данные и является изменяемым, то регулярно используется в стандартной библиотеке для совершенно разных целей. Строки же используются значительно реже.

### Срезы рун ([]rune)
Каждому символу назначен стандартный номер — код символа Unicode (Unicode code point), или, в терминологии Go, руна (rune).

Когда мы говорили о типах string и []byte, то выяснили, что 1 символ может занимать более одного байта. Слегка упрощая мы можем сказать, что тип []rune - это последовательность на самом деле кодов символов, причем 1 символ состоит из 1 кода (тип rune соответствует типу int32).

Методы работы с типом []rune показаны в следующем примере (обратите внимание на тип используемых в примере кавычек, это не те же самые кавычки, что мы используем при работе со строками):
```
func ExampleRune() {
	// Поступим также, как в работе с типом []byte
	rs := []rune("Это срез рун")

	// Итерируясь мы будем заменять символ 'р' на '*'
	for i := range rs {
		if rs[i] == 'р' {
			rs[i] = '*'
		}
	}
	fmt.Printf("Измененнный срез в виде строки: %s\n", string(rs))

	// Output:
	// Измененнный срез в виде строки: Это с*ез *ун
}
```

### Unicode
Помимо пакета strings, есть некоторые полезные функции из пакета unicode для работы с символами.
```
 // проверка символа на цифру
	fmt.Println(unicode.IsDigit('1')) // true
    // проверка символа на букву
	fmt.Println(unicode.IsLetter('a')) // true 
    // проверка символа на нижний регистр
	fmt.Println(unicode.IsLower('A')) // false
    // проверка символа на верхний регистр
	fmt.Println(unicode.IsUpper('A')) // true
    // проверка символа на пробел 
    // пробел это не только ' ', но и:
    //  '\t', '\n', '\v', '\f', '\r' - подробнее читайте в документации
	fmt.Println(unicode.IsSpace('\t')) // true 

    // С помощью функции Is можно проверять на кастомный RangeTable:
    // например, проверка на латиницу:
 	fmt.Println(unicode.Is(unicode.Latin, 'ы')) // false


    // функции преобразований
	fmt.Println(string(unicode.ToLower('F'))) // f
	fmt.Println(string(unicode.ToUpper('f'))) // F
```

### Количество символов в строке

Многие новички забывают что функция len() возвращает количество байт которое занимает строка, а не количество символов. Поэтому это будет работать только при использование латиницы и некоторых специальных символов (ASCII), так как они занимают 1 байт на 1 символ. А вот русские буквы уже занимают 2 байта на символ, мы можем это видеть в примере:

* Для получения количества символов используйте utf8.RuneCountInString() 
```
	var en = "english"
	var ru = "русский"
	fmt.Println(len(en), len(ru))  //   ​​​​​​​7 14 // en -7 байтов, ru - 14 байтов
	fmt.Println(utf8.RuneCountInString(en), utf8.RuneCountInString(ru))  //  7 7 // а длина у строк одинаковая
```

* Более изящный способ определения длины строки в символах:
> len([]rune(str))
Это не требует импорта пакета "unicode/utf8". Что тут происходит? Любые символы (хоть иероглифы) загоняются в срез рун, где всегда будет соблюдаться принцип "1 символ = 1 элемент среза, четырехразрядное число". И сразу определяется длина среза.

Совет. Если строка вам нужна больше 1 раза, то запишите этот срез в переменную strRunes := []rune(str). Делайте потом с ним, что хотите: range, измеряйте, меняйте местами буквы, перезаписывайте, добавляйте... Всякий раз, когда хотите снова из рун получить реальные символы - оберните элемент или весь срез в string():
> strRunes := []rune(str)
```
string(strRunes) //даст исходный текст
string(strRunes[i]) //даст і-тый символ
```



