### Функции
```
func имя_функции (список_параметров) (типы_возвращаемых_значений) {
    выполняемые_операторы
}
```

документация по функциям из консоли:
> go doc fmt.Println

Так же переменную можно объявить при указании типа возвращаемого значения. Например:
```
package main;
import "fmt";

func main() {
    fmt.Println(Add(1, 2));
}

func Add(x, y int) (result int) {
    result = x + y;
    
    return;
}
```

В Go функция может возвращать сразу несколько значений. В этом случае после списка параметров указывается в скобках список типов возвращаемых значений. А после оператора return располагаются через запятую все возвращаемые значения:
```
package main
import "fmt"
 
func main() {
    var age, name = add(4, 5, "Tom", "Simpson")
    fmt.Println(age)    // 9
    fmt.Println(name)   // Tom Simpson
}
 
func add(x, y int, firstName, lastName string) (int , string) {
    var z int = x + y
    var fullName = firstName + " " + lastName
    return z, fullName
}
```
Поскольку функция теперь возвращает два значения, то при вызове этой функции мы можем присвоить ее результат двум переменным:
```
var age, name = add(4, 5, "Tom", "Simpson")
```
+ Игнорирование возвращаемых значений
Go позволяет проигнорировать все или определенные возвращаемые функцией значения, если мы не будем использовать их в дальнейшем. Для этого нам необходимо не присваивать им имена вообще либо заменить имя символом _. Рассмотрим это на примере:
```
func fn() (int, error) {
	// Какая-то полезная работа
	// ...
	return 0, nil
}
func ExampleIgnor() {
	fn()

	i, _ := fn()
	fmt.Println(i)

	_, err := fn()
	if err == nil {
		fmt.Println("Ошибок нет")
	}

	// Output:
	// 0
	// Ошибок нет
}
```

+ Функции с переменным количеством параметров (аргументов)
```
func Print(a ...interface{}) (n int, err error) // interface мы рассмотрим в 3 модуле, это лишь для примера
```
```
func ExamplePrint() {
	fmt.Print(1, 2, 3, 4, 5)

	// Output:
	// 1 2 3 4 5
}
```
Под капотом примерно следующее:
```
func myPrint(a ...interface{}) {
	for _, elem := range a {
		fmt.Printf("%d ", elem)
	}
}

func ExampleMyPrint() {
	myPrint(1, 2, 3, 4, 5)

	// Output:
	// 1 2 3 4 5
}
```
Необходимо запомнить, что если функция принимает определенные аргументы и еще произвольное число аргументов определенного типа, то при объявлении функции эти «переменные» аргументы указываются в самом конце. Для примера:
```
func Fprint(w io.Writer, a ...interface{}) (n int, err error)
```
Эта функция принимает обязательный аргумент тип io.Writer и произвольное число аргументов типа interface{}.
+ Небольшое дополнение по использованию многоточия (...)
Как мы выяснили, знак многоточия слева от указания на тип передаваемого значения свидетельствует о возможности передать в функцию неопределенное количество аргументов указанного типа, внутри функции переданные аргументы будут обработаны как срез указанного в объявлении функции типа.

Однако язык Go предусматривает обратный способ использования многоточия - разворачивание (раскрытие) среза путем указания справа от среза знака многоточия. Приведу 2 примера:
```
func ExampleExpandSlice1() {
	s := []interface{}{1, 2, 3, 4, 5}

	fmt.Println(s)
	fmt.Println(s...)

	// Output:
	// [1 2 3 4 5]
	// 1 2 3 4 5
}
```
```
func ExampleExpandSlice2() {
	s1 := []int{1, 2, 3, 4, 5}
	s2 := []int{6, 7, 8, 9, 10}

	s1 = append(s1, s2...)
	fmt.Println(s1)

	// Output:
	// [1 2 3 4 5 6 7 8 9 10]
}
```

### Область видимости
В Go область видимости определяется лексическими блоками, к которым относятся:
+ синтаксические блоки (последовательность инструкций, заключенных в фигурные скобки);
+ прочие блоки, которые явно не ох­ватываются фигурными скобками в исходном тексте, но имеют схожее поведение: всеобщий блок, блок для каждого пакета, блок для каждого файла.
```
package main

import "fmt"

func scope() {
	v := 1
	fmt.Print(v)
}

func main() {
    /*
     * Если мы не станем рассматривать в данном случае вопрос о времени жизни переменной,
     * а сконцентрируемся только на области видимости, то можем констатировать, что из
     * функции main мы не можем получить доступа к переменной v, объявленной в функции
     * scope.
     */
	scope()
	fmt.Print(v) // ошибка компиляции
}
```
Программа может содержать несколько объявлений одного и того же имени при условии, что все объявления находятся в различных 
лексических блоках. Например, можно объявить локальную переменную с тем же именем, что и переменная уровня пакета. 
Компилятор же, встретив ссылку на имя, ищет объявление, начиная с наиболее глу­боко вложенного внутреннего лексического 
блока и продолжая до всеобщего блока. Если компилятор не обнаруживает объявление, он сообщает об ошибке "необъявленное имя". 
Если имя объявлено и в наружном, и во внутреннем блоках, первым будет обнаружено внутреннее объявление. В этом случае говорят, 
что внутреннее объявле­ние затеняет внешнее:
```
func ExampleScope1() {
	var v int = 1

	{
		/*
		 * Здесь переменная из внешнего лексического блока затеняется
		 * переменной внутреннего лексического блока
		 */
		var v string = "2"
		fmt.Println(v)
	}

	fmt.Println(v)

	/*
	 * В примере мы объявили в отдельных лексических блоках переменные с одним именем и
	 * разными типами, а затем напечатали значения этих переменных.
	 */

	// Output:
	// 2
	// 1
}
```

Цикл for создает два лексических блока: яв­ный блок для тела цикла и неявный блок, который дополнительно охватывает пере­менные, 
объявленные в инициализации цикла.
```
func ExampleScope2() {
	var i string = "Строка"

	/*
	 * Переменная i объявляется вне фигурных скобок, тем не менее это
	 * отдельная область видимости, к которой имеет доступ вторая область видимости,
	 * которая уже заключена в фигурные скобки
	 */
	for i := 0; i < 1; i++ {
		fmt.Println(i)
	}

	/*
	 * Аналогично примеру выше мы объявляем переменную i в области видимости
	 * вне фигурных скобок, а в теле цикла (отдельная область видимости) -
	 * затеняем переменную i
	 */
	for i := 0; i < 1; i++ {
		i := true
		fmt.Println(i)
	}

	fmt.Println(i)

	// Output:
	// 0
	// true
	// Строка
}
```
Шапка цикла for и тело - разные области видимостии:
```
func main() {
  var i string = "End"
  for i:=0; i<3; i++{
    i := true
    fmt.Print(i, " ")
  }
  fmt.Println(i)
}
// true true true End
```

> Аналогично конструкции цикла for такие неявные области видимости создаются конструкциями if, switch и select.


