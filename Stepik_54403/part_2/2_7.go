package m_2_7

import (
	"fmt"
	// "strconv"
	// "math"
)

func main() {

	fmt.Println("")
}

// Внимательно прочитайте ВСЕ условия и подсказки чтобы правильно решить задачу!
// Требуется вычислить период колебаний (t) математического маятника (мы округлили некоторые значения для удобства проверки),
// для этого нужно найти циклическую частоту колебания пружинного маятника (w), в формуле w встречается масса которую также нужно
// найти, все нужные формулы приведены ниже:

// Напишите три функции, каждая из которых будет выполнять конкретную формулу. Название функций обязательно должны соответствовать
// букве формулы: T(), W() и M(). Для того чтобы найти t - необходимо сначала найти w, и т.д. Так что используйте результат
// функции W() в формуле функции T() - то-есть вызывайте функцию W() в T(). Аналогично и с W(), M().
// t = 6/W
// w = sqrt(k/m)
// m = p*v

// func M() float64 {
// 	return p * v
// }

// func W() float64 {
// 	return (math.Sqrt(k / M()))
// }

// func T() float64 {
// 	return (6 / W())
//
//

// ВАЖНО! Считайте, что пакет main уже объявлен, а также функция main() с вызовом ВАШЕЙ будущей функции T() уже есть.
// Несмотря на то, что тестирование будет через ввод-вывод, вам НЕ требуется вводить и выводить что-либо. Для подсчета используйте
// УЖЕ ВВЕДЕННЫЕ ГЛОБАЛЬНЫЕ переменные k,p,v ТИПА float64 !!!

//
// На вход подается целое число. Необходимо возвести в квадрат каждую цифру числа и вывести получившееся число.
// Например, у нас есть число 9119. Первая цифра - 9. 9 в квадрате - 81. Дальше 1. Единица в квадрате - 1. В итоге получаем 811181
//
//
// var str string
// fmt.Scan(&str)
// for _, val := range str {
// 	dig, _ := strconv.Atoi(string(val))
// 	fmt.Printf("%d", (dig * dig))
// }
//
//
// вычитаем из ASCII-символа цифры значение ASCII-символа нуля, получаем собственно цифру.
// var s string
// fmt.Scan(&s)
// for _, c := range s {
// 	c -= '0'
// 	fmt.Print(c * c)
// }
//

//
//
// 1112221112
// fmt.Println("end")
// Решение задач
//
//
// Дана строка, содержащая только арабские цифры. Найти и вывести наибольшую цифру.
// Входные данные
// Вводится строка ненулевой длины. Известно также, что длина строки не превышает 1000 знаков и строка содержит только арабские цифры.
// Выходные данные
// Выведите максимальную цифру, которая встречается во введенной строке.
//
// var str string
// fmt.Scan(&str)
// var max int
// for _, val := range str {
// 	dig, _ := strconv.Atoi(string(val))

// 	if dig > max {
// 		max = dig
// 	}
// }
// fmt.Println(max)
//
//
// var s string
// _, _ = fmt.Scan(&s)

// без конвертаций. и с циклом с проверкой на 9, чтоб лишнее не крутить
// var max int32
// for _, d := range s {
// if d == 9 {
// 	max = 9
// 	break
// } else if d > max {
// 		max = d
// 	}
// }
// fmt.Println(string(max))

//
//
// Дана строка, содержащая только английские буквы (большие и маленькие). Добавить символ ‘*’ (звездочка) между буквами
// (перед первой буквой и после последней символ ‘*’ добавлять не нужно).

// Входные данные
// Вводится строка ненулевой длины. Известно также, что длина строки не превышает 1000 знаков.
// Выходные данные
// Вывести строку, которая получится после добавления символов '*'.
// Sample Input: LItBeoFLcSGBOFQxMHoIuDDWcqcVgkcRoAeocXO
// Sample Output: L*I*t*B*e*o*F*L*c*S*G*B*O*F*Q*x*M*H*o*I*u*D*D*W*c*q*c*V*g*k*c*R*o*A*e*o*c*X*O
//
// var str string
// fmt.Scan(&str)
// runeStr := []rune(str)
// for i := 0; i < len(runeStr)-1; i++ {
// 	fmt.Printf("%s*", string(runeStr[i]))
// }
// fmt.Printf(string(runeStr[len(runeStr)-1]))
//
// Вменсто костыля можно добавить вначала проверку на последний символ и выводить только его, и выходить из цикла через break
//
// 	fmt.Println(strings.Join(strings.Split(s, ""), "*")) – через Join
//

//
// На вход подаются a и b - катеты прямоугольного треугольника. Нужно найти длину гипотенузы
// Далее предполагаем, что a и b длины катетов, а c длина гипотенузы
// c^{2}=a^{2}+b^{2}
//
// var a, b float64
// fmt.Scan(&a, &b)
// fmt.Println(math.Hypot(a, b))
