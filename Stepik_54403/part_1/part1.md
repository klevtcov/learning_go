### Переменные

Переменная - первым символом должен быть либо алфавитный символ, либо символ подчеркивания. При этом имена не должны представлять одно из ключевых слов: 
```
break, case, chan, const, continue, default, defer, else, fallthrough, for, func, go, goto, if, import, interface, map, package, range, return, select, struct, switch, type, var
```

Для хранения символов можно использовать int32/rune. Здесь используются одинарные кавычки. Компилятор определяет код буквы в unicode и присваивает его переменной symbol. То есть мы не храним никакую 'c', а храним лишь число 99. Функция string() из переданного в него числа 99 делает строку 'c'.

```
var symbol int32 = 'c'
fmt.Println(string(symbol)) // 99
```


### Арифметические действия

При делении стоит быть внимательным, так как если в операции участвуют два целых числа, то результат деления будет округляться до целого числа:
```
var a int = 10 / 6    // 1
var m float32 = 10.0 / 6   // Вывод: 1.6666666
```

Возвращает остаток от деления (в этой операции могут принимать участие только целые числа):
```
var c int = 10 % 3   //  Вывод: 1
```

### Вывод данных на консоль

Для вывода данных на консоль мы на данном этапе будем пользоваться двумя методами, которые присутствуют в пакете fmt. 
Это Print() и Println().

Первый метод при выводе нескольких объектов вставляет между ними пробелы, если среди них нет строк.

Второй всегда ставит пробелы между выводимыми объектами, плюс добавляет новую строку. То есть он пригодится, если нам необходимо будет сделать вывод на нескольких строках.
```
fmt.Print("Ivan", 27) // Ivan27
fmt.Println("Ivan", 27) // Ivan 27
fmt.Print(33, 27) // 33 27
```

### Константы
Константы, как и переменные, хранят некоторые данные, но, в отличие от переменных, значения констант нельзя изменить, они устанавливаются один раз. Вычисление констант производится во время компиляции. Благодаря этому уменьшается количество работы, которую необходимо произвести во время выполнения, упрощается поиск ошибок, связанных с константами (так как некоторые из них можно обнаружить на момент компиляции).

Также можно не указывать значение следующей константы по порядку (значение будет скопировано):
```
const(
	A int = 45
	B
	C float32 = 3.3
	D
)
func main() {
	fmt.Println(A, B, C, D)  // Вывод: 45 45 3.3 3.3
}
```

* iota

iota идентификатор Go используется в объявлениях констант для упрощения определений увеличивающихся чисел.
Сделаем дни недели с использованием iota - теперь это выглядит проще (особенно если много данных):  
```
const (
	Sunday = iota
	Monday
	Tuesday
	Wednesday
	Thursday
	Friday
	Saturday
)

func main() {
	fmt.Println(Sunday)   // вывод 0
	fmt.Println(Saturday) // вывод 6
}
```

```
const (
  c0 = iota  // c0 == 0
  c1 = iota  // c1 == 1
  c2 = iota  // c2 == 2
)
fmt.Println(c0, c1, c2) // вывод: 0 1 2
```
```
const (
	Sunday = iota
	Monday
	Tuesday
	Wednesday
	Thursday
	Friday
	Saturday
	_  // пропускаем 7
	Add
)

fmt.Println(Sunday)   // вывод: 0
fmt.Println(Saturday) // вывод: 6
fmt.Println(Add) // вывод: 8
```
```
const (
	u         = iota * 42 // u == 0 (индекс - 0, поэтому 0 * 42 = 0)
	v float64 = iota * 42 // v == 42.0 (индекс - 1, поэтому 1.0 * 42 = 42.0)
	w         = iota * 42 // w == 84  (индекс - 2, поэтому 2 * 42 = 84)
)

// переменные ни в одном блоке const, поэтому индекс не увеличился
const x = iota  // x == 0
const y = iota  // y == 0
```


### Операции отношения
```
==
>
<
<=, >=
!=
```
* ! (операция отрицания, логическое НЕ)
```
var a bool = true
var b bool = !a     // false
var c bool = !b     // true
```
* && (конъюнкция, логическое умножение,  логическое И)
```
var b bool = 4 > 5 && 6 > 8   // false
var c bool = 3 <= 5 && 10 > 8 // true
```
* || (дизъюнкция, логическое сложение, логическое ИЛИ)
```
var b bool = 4 > 5 || 6 > 8      // false
var c bool = 3 == 5 || 10 > 8    // true
```


### Условная конструкция if
+ If с краткой инструкцией

Так же как и for, оператор if может начинаться с инструкции, которая будет выполнена перед проверкой условия.

Переменные объявленные в этом блоке доступны только в области видимости, которая существует до конца if.
```
if v := math.Pow(x, n); v < lim {
   // ...
}
```

* Switch
```
switch i {
case 0: fmt.Println("Zero")
case 1: fmt.Println("One")
case 2: fmt.Println("Two")
case 3: fmt.Println("Three")
case 4: fmt.Println("Four")
case 5: fmt.Println("Five")
default: fmt.Println("Unknown Number")
}
```


+ Если в текущем case написать fallthrough, то тело следующего case выполнится вне зависимости от того истинно ли его (следующего case) условие:
```
v := 42
switch v {
case 100:
	fmt.Println(100)
	fallthrough
case 42:
	fmt.Println(42)
	fallthrough
case 1:
	fmt.Println(1)
	fallthrough
default:
	fmt.Println("default")
}
// Вывод:
// 42
// 1
// default
```

+ Существует специальная форма switch, допускающая использование произвольных условий в каждом case-блоке:
```
var c uint32
fmt.Scan(&c)
switch {
case 1 <= c && c <= 9:
	fmt.Println("от 1 до 9")
case 100 <= c && c <= 250:
	fmt.Println("от 100 до 250")
case 1000 <= c && c <= 6000:
	fmt.Println("от 1000 до 6000")
}
```

