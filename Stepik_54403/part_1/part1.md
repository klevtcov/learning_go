### Переменные

Переменная - первым символом должен быть либо алфавитный символ, либо символ подчеркивания. При этом имена не должны представлять одно из ключевых слов: 
```
break, case, chan, const, continue, default, defer, else, fallthrough, for, func, go, goto, if, import, interface, map, package, range, return, select, struct, switch, type, var
```

Для хранения символов можно использовать int32/rune. Здесь используются одинарные кавычки. Компилятор определяет код буквы в unicode и присваивает его переменной symbol. То есть мы не храним никакую 'c', а храним лишь число 99. Функция string() из переданного в него числа 99 делает строку 'c'.

```
var symbol int32 = 'c'
fmt.Println(string(symbol)) // 99
```


### Арифметические действия

При делении стоит быть внимательным, так как если в операции участвуют два целых числа, то результат деления будет округляться до целого числа:
```
var a int = 10 / 6    // 1
var m float32 = 10.0 / 6   // Вывод: 1.6666666
```

Возвращает остаток от деления (в этой операции могут принимать участие только целые числа):
```
var c int = 10 % 3   //  Вывод: 1
```

### Вывод данных на консоль

Для вывода данных на консоль мы на данном этапе будем пользоваться двумя методами, которые присутствуют в пакете fmt. 
Это Print() и Println().

Первый метод при выводе нескольких объектов вставляет между ними пробелы, если среди них нет строк.

Второй всегда ставит пробелы между выводимыми объектами, плюс добавляет новую строку. То есть он пригодится, если нам необходимо будет сделать вывод на нескольких строках.
```
fmt.Print("Ivan", 27) // Ivan27
fmt.Println("Ivan", 27) // Ivan 27
fmt.Print(33, 27) // 33 27
```

### Константы
Константы, как и переменные, хранят некоторые данные, но, в отличие от переменных, значения констант нельзя изменить, они устанавливаются один раз. Вычисление констант производится во время компиляции. Благодаря этому уменьшается количество работы, которую необходимо произвести во время выполнения, упрощается поиск ошибок, связанных с константами (так как некоторые из них можно обнаружить на момент компиляции).

Также можно не указывать значение следующей константы по порядку (значение будет скопировано):
```
const(
	A int = 45
	B
	C float32 = 3.3
	D
)
func main() {
	fmt.Println(A, B, C, D)  // Вывод: 45 45 3.3 3.3
}
```

* iota

iota идентификатор Go используется в объявлениях констант для упрощения определений увеличивающихся чисел.
Сделаем дни недели с использованием iota - теперь это выглядит проще (особенно если много данных):  
```
const (
	Sunday = iota
	Monday
	Tuesday
	Wednesday
	Thursday
	Friday
	Saturday
)

func main() {
	fmt.Println(Sunday)   // вывод 0
	fmt.Println(Saturday) // вывод 6
}
```

```
const (
  c0 = iota  // c0 == 0
  c1 = iota  // c1 == 1
  c2 = iota  // c2 == 2
)
fmt.Println(c0, c1, c2) // вывод: 0 1 2
```
```
const (
	Sunday = iota
	Monday
	Tuesday
	Wednesday
	Thursday
	Friday
	Saturday
	_  // пропускаем 7
	Add
)

fmt.Println(Sunday)   // вывод: 0
fmt.Println(Saturday) // вывод: 6
fmt.Println(Add) // вывод: 8
```
```
const (
	u         = iota * 42 // u == 0 (индекс - 0, поэтому 0 * 42 = 0)
	v float64 = iota * 42 // v == 42.0 (индекс - 1, поэтому 1.0 * 42 = 42.0)
	w         = iota * 42 // w == 84  (индекс - 2, поэтому 2 * 42 = 84)
)

// переменные ни в одном блоке const, поэтому индекс не увеличился
const x = iota  // x == 0
const y = iota  // y == 0
```


### Операции отношения
```
==
>
<
<=, >=
!=
```
* ! (операция отрицания, логическое НЕ)
```
var a bool = true
var b bool = !a     // false
var c bool = !b     // true
```
* && (конъюнкция, логическое умножение,  логическое И)
```
var b bool = 4 > 5 && 6 > 8   // false
var c bool = 3 <= 5 && 10 > 8 // true
```
* || (дизъюнкция, логическое сложение, логическое ИЛИ)
```
var b bool = 4 > 5 || 6 > 8      // false
var c bool = 3 == 5 || 10 > 8    // true
```


### Условная конструкция if
+ If с краткой инструкцией

Так же как и for, оператор if может начинаться с инструкции, которая будет выполнена перед проверкой условия.

Переменные объявленные в этом блоке доступны только в области видимости, которая существует до конца if.
```
if v := math.Pow(x, n); v < lim {
   // ...
}
```

* Switch
```
switch i {
case 0: fmt.Println("Zero")
case 1: fmt.Println("One")
case 2: fmt.Println("Two")
case 3: fmt.Println("Three")
case 4: fmt.Println("Four")
case 5: fmt.Println("Five")
default: fmt.Println("Unknown Number")
}
```


+ Если в текущем case написать fallthrough, то тело следующего case выполнится вне зависимости от того истинно ли его (следующего case) условие:
```
v := 42
switch v {
case 100:
	fmt.Println(100)
	fallthrough
case 42:
	fmt.Println(42)
	fallthrough
case 1:
	fmt.Println(1)
	fallthrough
default:
	fmt.Println("default")
}
// Вывод:
// 42
// 1
// default
```

+ Существует специальная форма switch, допускающая использование произвольных условий в каждом case-блоке:
```
var c uint32
fmt.Scan(&c)
switch {
case 1 <= c && c <= 9:
	fmt.Println("от 1 до 9")
case 100 <= c && c <= 250:
	fmt.Println("от 100 до 250")
case 1000 <= c && c <= 6000:
	fmt.Println("от 1000 до 6000")
}
```

### Циклы в Go
```
for [инициализация счетчика]; [условие]; [изменение счетчика]{
    // действия
}
```

### Форматированный вывод
fmt.Printf("%q", a)
* %t: для вывода значений типа boolean (true или false)
* %b: для вывода целых чисел в двоичной системе
* %c: для вывода символов, представленных числовым кодом
* %d: для вывода целых чисел в десятичной системе
* %o: для вывода целых чисел в восьмеричной системе
* %q: для вывода символов в одинарных кавычках
* %x: для вывода целых чисел в шестнадцатеричной системе, буквенные символы числа имеют нижний регистр a-f
* %X: для вывода целых чисел в шестнадцатеричной системе, буквенные символы числа имеют верхний регистр A-F
* %U: для вывода символов в формате кодов Unicode, например, U+1234
* %e: для вывода чисел с плавающей точкой в экспоненциальном представлении, например, -1.234456e+78
* %E: тоже самое что %e но в верхнем регистре, например, -1.234456E+78
* %f: для вывода чисел с плавающей точкой, например, 123.456
* %F: то же самое, что и %f
* %g   %e для огромных экспонент, %f в противном случае
* %G    %E для огромных экспонент, %F в противном случае
* %s: для вывода строки
* %p: для вывода значения указателя - адреса в шестнадцатеричном представлении (указатели мы пройдем на следующих уроках)
* %T для вывода типа переменной
```
Также можно применять универсальный спецификатор %v, который для типа boolean аналогичен %t, для целочисленных типов - %d, для чисел с плавающей точкой - %g, для строк - %s.
```

```
var a = 3.14
fmt.Printf("|%8f|\n", a)
fmt.Printf("|%8.1f|\n", a)
fmt.Printf("|%8.3f|\n", a)
fmt.Printf("|%-8.3f|\n", a)

вывод:
|3.140000|
|     3.1|
|   3.140|
|3.140   |
```

### Sprintf – работает как и Printf(), за исключением того что она ничего не печатает, а возвращает результат форматирования
```
var a float64 = 100.123456789
result := fmt.Sprintf("%.2f", a)
fmt.Printf("%q", result) // вывод: "100.12"
// result будет типа string
```


### Литералы строк
* Литерал строк — это то, что мы видим в исходном коде компьютерной программы, включая кавычки. 
* Значение строки — это то, что мы видим в окне терминала когда вызываем функцию fmt.Println после запуска программы Go.
```
В Go можно использовать обратный апостроф (`) или двойные кавычки ("), поэтому мы можем легко вставлять цитаты в строку, выделяя их двойными кавычками, в то время как сама строка выделена обратными апострофами: `Sammy says, "Hello!"`
```

* Экранирование символов – fmt.Println("Sammy says, \"Hello!\"")
```
fmt.Println("1.\tShark\n2.\tShrimp\n10.\tSquid")
```
```
1.	Shark
2.	Shrimp
10.	Squid
```

* Мы можем создать чистую строку, заключив строку в обратные апострофы:
```
fmt.Println(`Sammy says,\"The balloon\'s color is red.\"`)
```
```
Sammy says,\"The balloon\'s color is red.\"
```

### Массивы
+ Массив — это последовательность элементов одного типа фиксированной длины. Объявление массива осуществляется следующим образом:
```
var a [3]int
fmt.Println(a) // [0 0 0]
```
При объявлении массива в квадратных скобках указывается его длина (length), которая совместно с типом элементов, определяет тип самого массива, т.е. [3]int не может просто так взаимодействовать с [5]int (массивы разной длины относятся к разным типам независимо от того, что хранят значения одного типа), также как не могут без приведения взаимодействовать int64 и int32.

```
var a [3]int = [3]int{1, 2, 3}
b := [3]int{1, 2, 3}
c := [...]int{1, 2, 3}
d := [3]int{1: 12}

fmt.Println(a) // [1 2 3]
fmt.Println(b) // [1 2 3]
fmt.Println(c) // [1 2 3] – "..." означает, что длинна масива будет определена в зависимости от переданных данных
fmt.Println(d) // [0 12 0] – 1:12, явно указываем значение элемента под индексом 1
```

+ Сравнение массивов
```
a := [3]int{1, 2, 3}
b := [3]int{1, 2, 3}
c := [3]int{3, 2, 1}
// можно сравнивать только массивы одного типа (массивы одинаковой длины, содержащие элементы одинакового типа).
fmt.Println(a == b) // true
fmt.Println(a == c) // false
```

+ Обращение к элементам массива. Индексы
```
var numbers [5]int = [5]int{1,2,3,4,5}    
fmt.Println(numbers[0])     // 1  
fmt.Println(numbers[4])     // 5   
numbers[0] = 87   
fmt.Println(numbers[0])     // 87
```
+ При итерации по массиву мы можем использовать ключевое слово range
```
for idx, elem := range a {
    fmt.Printf("Элемент с индексом %d: %d\n", idx, elem)
    // Элемент с индексом 0: 1
    // Элемент с индексом 1: 2
    // Элемент с индексом 2: 3
    // Элемент с индексом 3: 4
    // Элемент с индексом 4: 5
}
```

Range возвращает 2 объекта: индекс элемента в массиве и копию значения этого элемента. Любой из этих объектов должен быть опущен, если мы не планируем использовать его, для этого вместо имени переменной мы можем указать символ _. Кроме того, если мы хотим использовать только индекс элемента, мы можем вообще не использовать второе возвращаемое значение:

```
a := [5]int{1, 2, 3, 4, 5}
for idx := range a {
    fmt.Println(a[idx])
}
for idx, _ := range a {
    // В этом случае следует использовать приведенный выше вариант,
    // хотя технически эти варианты работают одинаково
    fmt.Println(a[idx])
}
for _, elem := range a {
    fmt.Println(elem)
}
```

+ Вывод: глобальные переменные зло, особенно при распараллеливании.  Объявлять примитивные переменные внутри цикла недорого.
```
func Fast() {
	for i := 0; i < 100; i++ {
		var a, b uint8 //объявляем переменные в цикле
		a, b = b*a, a+b
	}
}
func Slow() {
	var a, b uint8 //объявляем переменные вне цикла, но в функции
	for i := 0; i < 100; i++ {
		a, b = b*a, a+b
	}
}

var a, b uint8 //объявляем переменные вне функции
func VerySlow() {
	for i := 0; i < 100; i++ {
		a, b = b*a, a+b
	}
}
```
```
BenchmarkFast-6              380209788     31.04  ns/op
BenchmarkSlow-6              387787473     31.21  ns/op
BenchmarkVerySlow-6           45786147    255.4   ns/op
BenchmarkParallelFast-6     1000000000      5.395 ns/op
BenchmarkParallelSlow-6     1000000000      5.276 ns/op
BenchmarkParallelVerySlow-6   18877810    636.4   ns/op
```
```
func FastArray() {
	for i := 0; i < 5; i = i + 2 {
		in1 := workArray2[i]   //объявляем переменные в цикле
		in2 := workArray2[i+1]
		workArray1[in1], workArray1[in2] = workArray1[in2], workArray1[in1]
	}
}

var in1, in2 uint8 //объявляем глобальные переменные
func VerySlowArray() {
	for i := 0; i < 5; i = i + 2 {
		in1 = workArray2[i]   //в цикле используем глобальные переменные 
		in2 = workArray2[i+1]
		workArray1[in1], workArray1[in2] = workArray1[in2], workArray1[in1]
	}
}
```
### Разница скорости в два раза при однопоточном выполнении и в 23 раза при параллельном.
```
BenchmarkFastArray-6              321880726     3.611 ns/op      
BenchmarkVerySlowArray-6          165138084     7.344 ns/op      
BenchmarkParallelFastArray-6      108207138    11.23  ns/op     
BenchmarkParallelVerySlowArray-6    4567846   256.6   ns/op 
```

