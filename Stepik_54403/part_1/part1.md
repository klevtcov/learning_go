### Переменные

Переменная - первым символом должен быть либо алфавитный символ, либо символ подчеркивания. При этом имена не должны представлять одно из ключевых слов: 
```
break, case, chan, const, continue, default, defer, else, fallthrough, for, func, go, goto, if, import, interface, map, package, range, return, select, struct, switch, type, var
```

Для хранения символов можно использовать int32/rune. Здесь используются одинарные кавычки. Компилятор определяет код буквы в unicode и присваивает его переменной symbol. То есть мы не храним никакую 'c', а храним лишь число 99. Функция string() из переданного в него числа 99 делает строку 'c'.

```
var symbol int32 = 'c'
fmt.Println(string(symbol)) // 99
```


### Арифметические действия

При делении стоит быть внимательным, так как если в операции участвуют два целых числа, то результат деления будет округляться до целого числа:
```
var a int = 10 / 6    // 1
var m float32 = 10.0 / 6   // Вывод: 1.6666666
```

Возвращает остаток от деления (в этой операции могут принимать участие только целые числа):
```
var c int = 10 % 3   //  Вывод: 1
```

### Вывод данных на консоль

Для вывода данных на консоль мы на данном этапе будем пользоваться двумя методами, которые присутствуют в пакете fmt. 
Это Print() и Println().

Первый метод при выводе нескольких объектов вставляет между ними пробелы, если среди них нет строк.

Второй всегда ставит пробелы между выводимыми объектами, плюс добавляет новую строку. То есть он пригодится, если нам необходимо будет сделать вывод на нескольких строках.
```
fmt.Print("Ivan", 27) // Ivan27
fmt.Println("Ivan", 27) // Ivan 27
fmt.Print(33, 27) // 33 27
```

### Константы
Константы, как и переменные, хранят некоторые данные, но, в отличие от переменных, значения констант нельзя изменить, они устанавливаются один раз. Вычисление констант производится во время компиляции. Благодаря этому уменьшается количество работы, которую необходимо произвести во время выполнения, упрощается поиск ошибок, связанных с константами (так как некоторые из них можно обнаружить на момент компиляции).

Также можно не указывать значение следующей константы по порядку (значение будет скопировано):
```
const(
	A int = 45
	B
	C float32 = 3.3
	D
)
func main() {
	fmt.Println(A, B, C, D)  // Вывод: 45 45 3.3 3.3
}
```

* iota

iota идентификатор Go используется в объявлениях констант для упрощения определений увеличивающихся чисел.
Сделаем дни недели с использованием iota - теперь это выглядит проще (особенно если много данных):  
```
const (
	Sunday = iota
	Monday
	Tuesday
	Wednesday
	Thursday
	Friday
	Saturday
)

func main() {
	fmt.Println(Sunday)   // вывод 0
	fmt.Println(Saturday) // вывод 6
}
```

```
const (
  c0 = iota  // c0 == 0
  c1 = iota  // c1 == 1
  c2 = iota  // c2 == 2
)
fmt.Println(c0, c1, c2) // вывод: 0 1 2
```
```
const (
	Sunday = iota
	Monday
	Tuesday
	Wednesday
	Thursday
	Friday
	Saturday
	_  // пропускаем 7
	Add
)

fmt.Println(Sunday)   // вывод: 0
fmt.Println(Saturday) // вывод: 6
fmt.Println(Add) // вывод: 8
```
```
const (
	u         = iota * 42 // u == 0 (индекс - 0, поэтому 0 * 42 = 0)
	v float64 = iota * 42 // v == 42.0 (индекс - 1, поэтому 1.0 * 42 = 42.0)
	w         = iota * 42 // w == 84  (индекс - 2, поэтому 2 * 42 = 84)
)

// переменные ни в одном блоке const, поэтому индекс не увеличился
const x = iota  // x == 0
const y = iota  // y == 0
```


### Операции отношения
```
==
>
<
<=, >=
!=
```
* ! (операция отрицания, логическое НЕ)
```
var a bool = true
var b bool = !a     // false
var c bool = !b     // true
```
* && (конъюнкция, логическое умножение,  логическое И)
```
var b bool = 4 > 5 && 6 > 8   // false
var c bool = 3 <= 5 && 10 > 8 // true
```
* || (дизъюнкция, логическое сложение, логическое ИЛИ)
```
var b bool = 4 > 5 || 6 > 8      // false
var c bool = 3 == 5 || 10 > 8    // true
```


### Условная конструкция if
+ If с краткой инструкцией

Так же как и for, оператор if может начинаться с инструкции, которая будет выполнена перед проверкой условия.

Переменные объявленные в этом блоке доступны только в области видимости, которая существует до конца if.
```
if v := math.Pow(x, n); v < lim {
   // ...
}
```

* Switch
```
switch i {
case 0: fmt.Println("Zero")
case 1: fmt.Println("One")
case 2: fmt.Println("Two")
case 3: fmt.Println("Three")
case 4: fmt.Println("Four")
case 5: fmt.Println("Five")
default: fmt.Println("Unknown Number")
}
```


+ Если в текущем case написать fallthrough, то тело следующего case выполнится вне зависимости от того истинно ли его (следующего case) условие:
```
v := 42
switch v {
case 100:
	fmt.Println(100)
	fallthrough
case 42:
	fmt.Println(42)
	fallthrough
case 1:
	fmt.Println(1)
	fallthrough
default:
	fmt.Println("default")
}
// Вывод:
// 42
// 1
// default
```

+ Существует специальная форма switch, допускающая использование произвольных условий в каждом case-блоке:
```
var c uint32
fmt.Scan(&c)
switch {
case 1 <= c && c <= 9:
	fmt.Println("от 1 до 9")
case 100 <= c && c <= 250:
	fmt.Println("от 100 до 250")
case 1000 <= c && c <= 6000:
	fmt.Println("от 1000 до 6000")
}
```

### Циклы в Go
```
for [инициализация счетчика]; [условие]; [изменение счетчика]{
    // действия
}
```

### Форматированный вывод
fmt.Printf("%q", a)
* %t: для вывода значений типа boolean (true или false)
* %b: для вывода целых чисел в двоичной системе
* %c: для вывода символов, представленных числовым кодом
* %d: для вывода целых чисел в десятичной системе
* %o: для вывода целых чисел в восьмеричной системе
* %q: для вывода символов в одинарных кавычках
* %x: для вывода целых чисел в шестнадцатеричной системе, буквенные символы числа имеют нижний регистр a-f
* %X: для вывода целых чисел в шестнадцатеричной системе, буквенные символы числа имеют верхний регистр A-F
* %U: для вывода символов в формате кодов Unicode, например, U+1234
* %e: для вывода чисел с плавающей точкой в экспоненциальном представлении, например, -1.234456e+78
* %E: тоже самое что %e но в верхнем регистре, например, -1.234456E+78
* %f: для вывода чисел с плавающей точкой, например, 123.456
* %F: то же самое, что и %f
* %g   %e для огромных экспонент, %f в противном случае
* %G    %E для огромных экспонент, %F в противном случае
* %s: для вывода строки
* %p: для вывода значения указателя - адреса в шестнадцатеричном представлении (указатели мы пройдем на следующих уроках)
* %T для вывода типа переменной
```
Также можно применять универсальный спецификатор %v, который для типа boolean аналогичен %t, для целочисленных типов - %d, для чисел с плавающей точкой - %g, для строк - %s.
```

```
var a = 3.14
fmt.Printf("|%8f|\n", a)
fmt.Printf("|%8.1f|\n", a)
fmt.Printf("|%8.3f|\n", a)
fmt.Printf("|%-8.3f|\n", a)

вывод:
|3.140000|
|     3.1|
|   3.140|
|3.140   |
```

### Sprintf – работает как и Printf(), за исключением того что она ничего не печатает, а возвращает результат форматирования
```
var a float64 = 100.123456789
result := fmt.Sprintf("%.2f", a)
fmt.Printf("%q", result) // вывод: "100.12"
// result будет типа string
```


### Литералы строк
* Литерал строк — это то, что мы видим в исходном коде компьютерной программы, включая кавычки. 
* Значение строки — это то, что мы видим в окне терминала когда вызываем функцию fmt.Println после запуска программы Go.
```
В Go можно использовать обратный апостроф (`) или двойные кавычки ("), поэтому мы можем легко вставлять цитаты в строку, выделяя их двойными кавычками, в то время как сама строка выделена обратными апострофами: `Sammy says, "Hello!"`
```

* Экранирование символов – fmt.Println("Sammy says, \"Hello!\"")
```
fmt.Println("1.\tShark\n2.\tShrimp\n10.\tSquid")
```
```
1.	Shark
2.	Shrimp
10.	Squid
```

* Мы можем создать чистую строку, заключив строку в обратные апострофы:
```
fmt.Println(`Sammy says,\"The balloon\'s color is red.\"`)
```
```
Sammy says,\"The balloon\'s color is red.\"
```

