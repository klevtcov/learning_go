package main

import (
	// "bytes"
	"fmt"
)

func main() {

	fmt.Println("end")
}

// В ходе анализа результатов переписи населения информация была сохранена в объекте типа map:
// groupCity := map[int][]string{
// 	10:   []string{...}, // города с населением 10-99 тыс. человек
// 	100:  []string{...}, // города с населением 100-999 тыс. человек
// 	1000: []string{...}, // города с населением 1000 тыс. человек и более
// }

// При подготовке важного отчета о городах с населением 100-999 тыс. человек был подготовлен другой объект типа map:

// cityPopulation := map[string]int{
// 	город: население города в тысячах человек,
// }

// Однако база данных с информацией о точной численности населения содержала ошибки, поэтому в cityPopulation в т.ч.
// была сохранена информация о городах, которые входят в другие группы из groupCity.
// Ваша программа имеет доступ к обоим указанным отображениям, требуется исправить cityPopulation, чтобы в ней была
// сохранена информация только о городах из группы groupCity[100].
// Функция main() уже объявлена, доступ к отображениям осуществляется по указанным именам. По результатам выполнения
// ничего больше делать не требуется, проверка будет осуществлена автоматически.
//
//
// groupCity := map[int][]string{
// 	10:   []string{"Moscaov", "Klinton", "kirovsk"}, // города с населением 10-99 тыс. человек
// 	100:  []string{"CPB", "NVZ", "Briansk"},         // города с населением 100-999 тыс. человек
// 	1000: []string{"KIpr", "Harkov", "Novosibirsk"}, // города с населением 1000 тыс. человек и более
// }

// cityPopulation := map[string]int{
// 	"Moscaov":     54,
// 	"Klinton":     65,
// 	"kirovsk":     789,
// 	"CPB":         345,
// 	"NVZ":         548,
// 	"Briansk":     579,
// 	"KIpr":        65468,
// 	"Harkov":      78645,
// 	"Novosibirsk": 57498,
// }

// enotherMap := make(map[string]int)
// for key, value := range groupCity[100] {
// 	enotherMap[value] = key
// }

// for key, _ := range cityPopulation {
// 	if _, ok := enotherMap[key]; !ok {
// 		delete(cityPopulation, key)
// 	}
// }
//
// 	Без промежуточного массива, просто перебрать два других и удалить их значения из нашего
// for _, city := range groupCity[1000] {
// 	delete(cityPopulation, city)
// }

// for _, city := range groupCity[10] {
// 	delete(cityPopulation, city)
// }
//
//
//
// Внутри функции main (объявлять функцию не нужно) необходимо написать программу:
// На стандартный ввод подается 10 целых чисел, разделенных пробелами (числа могут повторяться). Для чтения из стандартного ввода импортирован пакет fmt.
// Вам необходимо вычислить результат выполнения функции work для каждого из полученных чисел. Функция work имеет следующий вид:
// func work(x int) int
// Результаты вычислений , разделенные пробелами, должны быть напечатаны в строку.
// Однако работа функции work занимает слишком много времени. Выделенного вам времени выполнения не хватит на последовательную обработку
// каждого числа, поэтому необходимо реализовать кэширование уже готовых результатов и использовать их в работе.
// После завершения работы программы результат выполнения будет дополнен информацией о соблюдении установленного лимита времени выполнения.
//
// Берём число, если для него ещё нет высчитанного результата функции - то считаем, иначе берём сразу из таблицы готовый ответ.
// var n int
// mapInt := make(map[int]int)
// for i := 0; i < 10; i++ {
// 	fmt.Scan(&n)
// 	if value, ok := mapInt[n]; ok {
// 		fmt.Printf("%d ", value)
// 	} else {
// 		mapInt[n] = work(n)
// 		fmt.Printf("%d ", mapInt[n])
// 	}
// }
//
// Аналогично, но более правильная запись - если НЕТ значения, то выполняем, потом выводим сообщение по ключу в любом случае
// cache := make(map[int]int, 10)
// for n, i := 0, 0; i < 10; i++ {
// 	fmt.Scan(&n)
// 	if _, exists := cache[n]; !exists {
// 		cache[n] = work(n)
// 	}
// 	fmt.Print(cache[n], " ")
// }
//
//
