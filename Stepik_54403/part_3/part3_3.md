## Анонимные функции

### Функции как объекты первого класса

В Go функции являются объектами первого класса, это значит, что в этом языке программирования функцию можно передать в качестве аргумента другой функции или же вернуть функцию в качестве значения. Подробнее об этом можно почитать в Википедии здесь и здесь.

Рассмотрим передачу функции в качестве аргумента другой функции на примере Map из уже знакомого нам пакета strings. Эта функция выглядит так:
> func Map(mapping func(rune) rune, s string) string
Функция Map в качестве первого аргумента получает функцию вида func (rune) rune, производящей какие-то действия с символом Unicode и возвращающей в качестве результата символ Unicode. Из описания этой функции следует, что переданная в качестве аргумента функция будет применена к каждому символу строки, переданной в качестве второго аргумента функции Map, получившаяся строка будет возвращена в качестве результата.
Создадим такую функцию:
```
func invert(r rune) rune {
	// Если буква строчная, то она возвращается заглавной
	if unicode.IsLower(r) {
		return unicode.ToUpper(r)
	}
	// Иначе возвращается строчной
	return unicode.ToLower(r)
}
```
А теперь используем ее:
```
func ExampleFirstClassFunctionArgument() {
	src := "aBcDeFg"
	test := "AbCdEfG"

	// Обратите внимание, что скобки после имени функции используются только при ее вызове
	src = strings.Map(invert, src)

	fmt.Printf("Инвертированная строка: %s. Результат: %v.\n", src, src == test)

	// Output:
	// Инвертированная строка: AbCdEfG. Результат: true.
}
```
Аналогично мы можем вернуть функцию в качестве значения:
```
func returnFunction() func(rune) rune {
	return invert
}
```

### Анонимная функция
Ранее, объявляя функцию, мы давали этой функции имя. Такое объявление можно сделать только за пределами других функций (на уровне пакета). Объявляя функцию на уровне пакета мы имеем возможность написать для такой функции необходимые тесты и удобно изменять ее реализацию. В этом нам в т.ч. помогает определенный уровень изоляции области видимости такой функции.

Однако в ряде случаев нам необходимо выполнить определенную задачу на месте, возможно предоставив функции доступ к области видимости вызывающей функции, как быть в этом случае? Язык Go позволяет нам использовать анонимные функции в любом выражении. Литерал такой функции записывается как объявление функции, но без имени после ключевого слова func.

Давайте немного изменим пример с функцией Map из пакета strings:
```
func ExampleFunctionWithoutName() {
	src := "aBcDeFg"
	test := "AbCdEfG"

	// Обратите внимание, что скобки после имени функции используются только при ее вызове
	src = strings.Map(func(r rune) rune {
		if unicode.IsLower(r) {
			return unicode.ToUpper(r)
		}
		return unicode.ToLower(r)
	}, src)

	fmt.Printf("Инвертированная строка: %s. Результат: %v.\n", src, src == test)

	// Output:
	// Инвертированная строка: AbCdEfG. Результат: true.
}
```
В этом примере мы передали функции Map в качестве аргумента анонимную функцию, общий результат работы от этого не изменился.
Анонимные функции могут быть объявлены в другой функции, присвоены переменной или вызваны на месте:
```
func ExampleUseNoNameFunction() {
	// Присваиваем переменной значение анонимной функции
	fn := func(a, b int) int { return a + b }

	// Выполняем анонимную функцию на месте
	// Обратите внимание на использование скобок при вызове функции
	func(a, b int) {
		fmt.Println(a + b)
	}(12, 34)

	fmt.Println(fn(17, 15))

	// Output:
	// 46
	// 32
}
```
В примере мы присвоили переменной fn функцию вида func(int, int) int, затем выполнили другую анонимную функцию, а затем выполнили функцию, присвоенную переменной fn. Обратите внимание на использование скобок в примерах - вызов функции требует наличия скобок, в которых указываются передаваемые функции аргументы (если аргументы не передаются - скобки пустые).

### Область видимости анонимной функции. Замыкание
В отличие от именованной функции, функция анонимная имеет доступ к окружению, в котором она была объявлена (в некоторых случаях объявление и вызов анонимной функции происходит одновременно):
```
func externalFunction() func() {
	text := "TEXT"

	return func() {
		fmt.Println(text)
	}
}

func ExampleEnvironment() {
	fn := externalFunction()
	fn()

	// Output:
	// TEXT
}
```
Когда анонимная функция использует переменные, объявленные за ее рамками, ее называют замыканием. В приведенном примере мы объявили именованную функцию externalFunction, в которой объявляется переменная text. В качестве значения функция externalFunction возвращает замыкание - анонимную функцию, которая имеет доступ к переменной text, объявленной за ее пределами. Затем мы присвоили переменной fn результат выполнения функции externalFunction. Теперь fn - функция, мы вызываем ее, тем самым печатаем значение переменной text.

Усложним пример:
```
func ExampleClosure() {
	fn := func() func(int) int {
		count := 0
		return func(i int) int {
			count++
			return count * i
		}
	}()

	for i := 1; i <= 5; i++ {
		fmt.Println(fn(i))
	}

	// Output:
	// 1
	// 4
	// 9
	// 16
	// 25
}
```
Здесь мы не просто печатаем значение переменной, но и изменяем его.
> а почему это чудо не сбрасывает счётчик, на каждом шаге ведь по идее должна быть инициализация count по новой?
в этом и суть замыкания. Создаётся функция (A), в ней своя область видимости, в которой объявляется переменная count со значением 0, затем из этой функции возвращается другая функция (B), которая в свою очередь использует переменную count из области видимости функции A, что влечет за собой её постоянное существование до тех пор, пока существует та функция B, которую мы вернули.

В простом объявлении функции и последующем её вызове, на момент её использования существую ссылки на переменные, по завершению работы функции эти ссылки перестают существовать, что влечет за собой освобождение памяти, при замыкании этого освобождения памяти не происходит, так как после завершения работы функции А остаётся ссылка на переменную count в функции B.

### Отложенный вызов анонимной функции
Мы уже говорили про defer в 2 модуле, напомним вам. Go позволяет отложить вызов внутренней функции до завершения функции внешней. Делается это с помощью ключевого слова defer перед вызовом функции. Отложенные функции выполняюся в обратном порядке (LIFO):
```
func ExampleDefer1() {
	defer func() { fmt.Println(1) }()
	defer func() { fmt.Println(2) }()
	defer func() { fmt.Println(3) }()
	// Output:
	// 3
	// 2
	// 1
}
```
С помощью отложенного вызова часто закрываются файлы и соединения, а также осуществляется обработка паники в работе функции, при этом используются возможности анонимных функций.

Как вы знаете, возбуждение аварии осуществляется вызовом функции panic(), которой в качестве аргумента передается любой требуемый объект. Восстановление же после аварии осуществляется вызовом функции recover(), возвращающей переданный функции panic() аргумент. При этом функция recover() может быть обработана, если ее вызов отложен до возникновения аварии:
```
func someFuncWithPanic() (err error) {
	defer func() {
		// отложенный вызов анонимной функции, проверяющей, что работа функции завершена
		// без ошибок. Если функция recover() возвращает что угодно кроме nil, значит в ходе
		// выполнения функции возникла паника.
		if e := recover(); e != nil {
			// Здесь происходит приведение интерфейса (об этом мы расскажем буквально в
			// следующем уроке. Результат приведения присваивается переменной err типа error
			// которая уже объявлена при самом вызове функции someFuncWithPanic.
			err = e.(error)

			// после этого анонимная функция завершает свою работу, паника обработана,
			// переменная err, в которой содержится информации о возникшей панике,
			// возвращается как результат выполнения функции.
		}
	}()

	panic(errors.New("fatal error"))
}

func ExamplePanicRecover() {
	if err := someFuncWithPanic(); err != nil {
		fmt.Println(err)
	}

	// Output:
	// fatal error
}
```

