## Конкурентность (Concurrency) и параллелизм (Parallelism)

* https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part2.html

Конкурентность предполагает работу приложения с двумя и более задачами одновременно, когда происходит создание нескольких процессов, выполняющихся независимо друг от друга. Когда мы начинаем говорить о многопоточной разработке, нужно ввести такие понятия, как Concurrency и Parallelism. В мире Go есть выражение «Concurrency is not Parallelism». Суть в том, что Concurrency — это о дизайне, то есть о том, как мы проектируем нашу программу. Parallelism — это просто способ выполнения нашего кода.

Конкурентность предполагает работу приложения с двумя и более задачами одновременно, когда происходит создание нескольких процессов, выполняющихся независимо друг от друга.

Приложения могут иметь дело с большим количеством процессов сразу для достижения желаемого поведения. Допустим, есть простенький интернет-магазин. Посмотрим, какие могут быть одновременно выполняемые задачи. Вот их список:

* Запуск на выполнение баннера с последними предложениями и продуктами cверху страницы.
* Показ количества пользователей на сайте в данный момент.
* Обновление содержимого корзины при выборе продуктов.
* Ведение счётчика времени до следующей распродажи и так далее.

Для интернет-магазина важно, чтобы все эти задачи выполнялись одновременно, ведь нужно удержать пользователей на сайте или в приложении, сделав его максимально привлекательным для них, чтобы они оставили здесь свои деньги. Поэтому можно сделать так, чтобы на простом сайте в фоновом режиме выполнялось множество задач.

## Конкурентное и параллельное выполнение

### Работа с конкурентными приложениями
Допустим, у нас одноядерная система и надо выполнить несколько задач, но есть ограничение: одномоментно может быть выполнена лишь одна задача.

В модели конкурентного выполнения имеет место переключение контекста между задачами: приложение работает с несколькими задачами, но не может выполнять их все вместе, ведь ядро всего одно. Переключение контекста происходит настолько быстро, что создаётся ощущение, что задачи выполняются одновременно.

Фактор параллельного выполнения здесь отсутствует: параллельные процессы не могут выполняться вместе просто потому, что наша система одноядерная.

### Добавим приложению параллелизма
В случае с одноядерной системой у нас были ограничения по ресурсам. Если мы добавим несколько ядер, ресурсов станет больше и приложение сможет одновременно выполнять на разных ядрах множество задач. В верхней части той же картинки показано, как на разных ядрах одновременно и параллельно выполняются две задачи.

Конкурентность и параллелизм — очень похожие понятия, но мне кажется, что разницу вы уже уловили.

Таким образом, увеличивая сложность системы, можно увеличить и сложность решаемых с её помощью задач: работая с Golang, мы можем масштабировать приложение, с лёгкостью переходя от конкурентного исполнения к параллельному. Масштабируемость в Golang — это легко!

con_vs_par.png

## Горутины
Горутины реализуют в Golang обёрточный функционал потоков, а управляются они скорее из среды выполнения Go, нежели из операционной системы.

Среда выполнения Go распределяет или забирает ресурсы памяти у горутин. Горутина во многом похожа на поток тем, что касается выполнения множества задач, но потребляет меньше ресурсов, чем потоки операционной системы. Горутина не имеет полного соответствия с потоками.

Горутины (goroutines) представляют параллельные операции, которые могут выполняться независимо от функции, в которой они запущены. Главная особенность горутин состоит в том, что они могут выполняться параллельно. То есть на многоядерных архитектурах есть возможность выполнять отдельные горутины на отдельных ядрах процессора, тем самым горутины будут выполняться паралелльно, и программа завершится быстрее.
 

В Go независимо запущенная задача называется горутиной. Горутины похожи на корутины (из котлина), процессы или потоки в других языках, хотя у них есть много своих особенностей. Их создание рационально, оно значительно упрощает процесс управления многими конкурентными операциями.

Преимущества горутин:

* Они легковесны.
* Легко и без проблем масштабируют.
* Они — практически потоки.
* Требуют меньше памяти (2KB).
* Предоставляют дополнительную память горутинам во время выполнения.

### Запуск горутины в Golang

Запуск горутины очень прост, достаточно прописать перед функцией ключевое слово "go", например:
```
package main

import "fmt"

func main() {
	go myFunc()
}

func myFunc() {
	fmt.Println("hello")
}
```
Все действительно так просто. Вот только если выполнить эту программу, то мы ничего не увидим. Это связано с тем, что после запуска myFunc в отдельной горутине (на это указывает ключевое слово go), функция main продолжает выполняться и завершается, не дожидавшись завершения выполнения всех прочих горутин, соответственно myFunc просто не успевает завершить выполнение. Go предусматривает несколько способов синхронизации выполнения горутин и мы рассмотри их в этом уроке.

Небольшое отступление. Go очень быстр, а нам требуется увидеть результат выполнения работы, а значит - замедлить нашу программу. Для этого мы будем использовать пакет time из стандартной библиотеки который был рассмотрен на прошлом уроке. Внесем небольшие изменения в наш пример:
```
package main

import (
	"fmt"
	"time"
)

func main() {
	go myFunc()
	time.Sleep(1 * time.Second) // Пауза в 1 секунду
}

func myFunc() {
	fmt.Println("hello")
}

// Вывод: hello
```
Теперь все работает. Количество горутин, которые мы можем запустить, не ограничено.

### Анонимные горутины
```
//Самовызывающаяся анонимная горутина
go func() {
 fmt.Println("Привет, я анонимная горутина")
}()
```

Это позволяет писать код, который используется в одном месте и сразу вызвать, не заботясь об объявлении функции

### Функция main()
Удивительно, но функция main() вызывает свою собственную горутину.

По умолчанию используется кол-во ядер вашего процессора. Но мы можем изменить количество используемых ядер простой строчкой кода. Приложению будет дана команда перейти на 4 ядра:

> runtime.GOMAXPROCS(4)

примеры горутин
> https://play.golang.org/p/caWNyYWZ91E

* https://habr.com/ru/post/412715/

### Каналы
Основное преимущество Go заключается в том, что он не просто позволяет выполнять несколько задач параллельно и конкурентно, но позволяет организовать удобную связь между горутинами при выполнении этих задач. Для этой цели используются каналы, по которым как по системе пневматической почты в старых офисах мы можем передавать данные.

Канал представляет собой механизм связи, который позволяет одной горутине отправлять некоторые значения другой горутине. Каждый канал является средством передачи значений определённого типа, который называется типом элементов канала.

Чтобы создать канал используется встроенная функция make:
```
channel := make(chan int)    // channel имеет тип 'chan int'
```

Как и отображение, канал является ссылкой на структуру данных. Копируя или передавая канал в функцию в качестве аргумента, мы копируем ссылку на одну и ту же структуру данных. Нулевым значением канала является nil.

Канал имеет две основные операции:

* Отправление (запись) - передаёт через канал значение из одной горутины в другую.
* Получение (чтение) - получение через канал значения из другой горутины.

Обе операции записываются с использованием оператора <b><-</b>, например:
```
channel <- num    // отправляет в канал channel значение num
num = <- channel  // получение из канала channel в переменную num
```
Чтение из канала может производится в цикле:
```
for v := range channel {
    ...
}
```
В приведенном примере чтение из канала будет осуществляться пока канал channel открыт.

Каналы поддерживают операцию закрытия встроенной функцией close:
> close(channel)
Эта функция устанавливает, что данные с помощью этого канала больше не будут передаваться.

Попытка передать данные в закрытый канал приведет к возникновению аварийной ситуации, однако операция получения будет работать и с закрытым каналом - будут получены все значения, которые были отправлены, но еще не прочитаны. После получения всех значений из канала, будет возвращаться нулевое значение типа канала.

Тип канала - не единственная его характеристика. Каждый канал имеет длину и емкость (их можно получить с помощью знакомых нам функций len() и cap()): длина - количество значений в канале в текущий момент, емкость - размер буфера. Наличие буфера позволяет записать в канал определенное количество значений, не вычитывая их при этом.

При отправлении значения в небуферизованный канал отправляющая горутина блокируется до тех пор, пока другая горутина не выполнит получение из этого канала. После этого обе горутины продолжают работать. Верно и обратное, если горутина получает значение, она блокируется, пока значение не будет получено.

Для того, чтобы разобраться в этом вопросе, рассмотрим следующий пример:
```
c := make(chan int, 1) // здесь 1 - размер буфера
fmt.Println(len(c), cap(c)) // 0 1
c <- 1
fmt.Println(len(c), cap(c)) // 1 1
<-c
```

Если же размер буфера будет 0, то выполнение программы приведет к панике, так как записанное значение одновременно с записью в канал не вычитывается. Но об этом мы расскажем подробнее чуть позже, в настоящее время достаточно знать, что такое буферезированные каналы:
```
pipe := make(chan int)     // небуферизованный канал
pipe := make(chan int, 0)  // небуферизованный канал
pipe := make(chan int, 5)  // буферизованный канал с ёмкостью 5
```
Буферизованные каналы имеют очередь элементов. Размер очереди задается при создании канала:

>channel := make(chan string, 3) // буферизованный канал, который может хранить три строковых значения

Операция отправления в буферизованный канал добавляет элемент в конец очереди:

> channel <- "A"

Операция получения извлекает первый элемент из очереди:

> fmt.Println(<-channel) // "A"

Если канал заполнен, операция отправления блокирует свою горутину, до тех пор, пока другая горутина не освободит место, получив данные из канала.

Выбор между буферизованным и небуферизованным каналом, как и выбор емкости каналов, может влиять на корректность работы программы в целом. Небуферизованные каналы дают более надежные гарантии синхронизации, потому что каждая операция отправления связана с операцией получения. В случае буферизованных каналов, эти операции разделены.

### Блокирование выполнения горутины

В некоторых случаях горутины могут быть заблокированы:

блокирование при записи: горутина, посылающая данные в канал, блокируется, пока другая горутина не прочитает данные из этого канала;
блокирование при чтении: горутина, получающая данные из канала,  может быть заблокирована до момента получения данных из канала.
Подробнее про блокировки мы расскажем в следующем уроке. 

* https://m.habr.com/ru/post/490336/ - Анатомия каналов в Go

