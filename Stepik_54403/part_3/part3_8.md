## Конкурентность (Concurrency) и параллелизм (Parallelism)

* https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part2.html

Конкурентность предполагает работу приложения с двумя и более задачами одновременно, когда происходит создание нескольких процессов, выполняющихся независимо друг от друга. Когда мы начинаем говорить о многопоточной разработке, нужно ввести такие понятия, как Concurrency и Parallelism. В мире Go есть выражение «Concurrency is not Parallelism». Суть в том, что Concurrency — это о дизайне, то есть о том, как мы проектируем нашу программу. Parallelism — это просто способ выполнения нашего кода.

Конкурентность предполагает работу приложения с двумя и более задачами одновременно, когда происходит создание нескольких процессов, выполняющихся независимо друг от друга.

Приложения могут иметь дело с большим количеством процессов сразу для достижения желаемого поведения. Допустим, есть простенький интернет-магазин. Посмотрим, какие могут быть одновременно выполняемые задачи. Вот их список:

* Запуск на выполнение баннера с последними предложениями и продуктами cверху страницы.
* Показ количества пользователей на сайте в данный момент.
* Обновление содержимого корзины при выборе продуктов.
* Ведение счётчика времени до следующей распродажи и так далее.

Для интернет-магазина важно, чтобы все эти задачи выполнялись одновременно, ведь нужно удержать пользователей на сайте или в приложении, сделав его максимально привлекательным для них, чтобы они оставили здесь свои деньги. Поэтому можно сделать так, чтобы на простом сайте в фоновом режиме выполнялось множество задач.

## Конкурентное и параллельное выполнение

### Работа с конкурентными приложениями
Допустим, у нас одноядерная система и надо выполнить несколько задач, но есть ограничение: одномоментно может быть выполнена лишь одна задача.

В модели конкурентного выполнения имеет место переключение контекста между задачами: приложение работает с несколькими задачами, но не может выполнять их все вместе, ведь ядро всего одно. Переключение контекста происходит настолько быстро, что создаётся ощущение, что задачи выполняются одновременно.

Фактор параллельного выполнения здесь отсутствует: параллельные процессы не могут выполняться вместе просто потому, что наша система одноядерная.

### Добавим приложению параллелизма
В случае с одноядерной системой у нас были ограничения по ресурсам. Если мы добавим несколько ядер, ресурсов станет больше и приложение сможет одновременно выполнять на разных ядрах множество задач. В верхней части той же картинки показано, как на разных ядрах одновременно и параллельно выполняются две задачи.

Конкурентность и параллелизм — очень похожие понятия, но мне кажется, что разницу вы уже уловили.

Таким образом, увеличивая сложность системы, можно увеличить и сложность решаемых с её помощью задач: работая с Golang, мы можем масштабировать приложение, с лёгкостью переходя от конкурентного исполнения к параллельному. Масштабируемость в Golang — это легко!

con_vs_par.png

## Горутины
Горутины реализуют в Golang обёрточный функционал потоков, а управляются они скорее из среды выполнения Go, нежели из операционной системы.

Среда выполнения Go распределяет или забирает ресурсы памяти у горутин. Горутина во многом похожа на поток тем, что касается выполнения множества задач, но потребляет меньше ресурсов, чем потоки операционной системы. Горутина не имеет полного соответствия с потоками.

Горутины (goroutines) представляют параллельные операции, которые могут выполняться независимо от функции, в которой они запущены. Главная особенность горутин состоит в том, что они могут выполняться параллельно. То есть на многоядерных архитектурах есть возможность выполнять отдельные горутины на отдельных ядрах процессора, тем самым горутины будут выполняться паралелльно, и программа завершится быстрее.
 

В Go независимо запущенная задача называется горутиной. Горутины похожи на корутины (из котлина), процессы или потоки в других языках, хотя у них есть много своих особенностей. Их создание рационально, оно значительно упрощает процесс управления многими конкурентными операциями.

Преимущества горутин:

* Они легковесны.
* Легко и без проблем масштабируют.
* Они — практически потоки.
* Требуют меньше памяти (2KB).
* Предоставляют дополнительную память горутинам во время выполнения.

### Запуск горутины в Golang

Запуск горутины очень прост, достаточно прописать перед функцией ключевое слово "go", например:
```
package main

import "fmt"

func main() {
	go myFunc()
}

func myFunc() {
	fmt.Println("hello")
}
```
Все действительно так просто. Вот только если выполнить эту программу, то мы ничего не увидим. Это связано с тем, что после запуска myFunc в отдельной горутине (на это указывает ключевое слово go), функция main продолжает выполняться и завершается, не дожидавшись завершения выполнения всех прочих горутин, соответственно myFunc просто не успевает завершить выполнение. Go предусматривает несколько способов синхронизации выполнения горутин и мы рассмотри их в этом уроке.

Небольшое отступление. Go очень быстр, а нам требуется увидеть результат выполнения работы, а значит - замедлить нашу программу. Для этого мы будем использовать пакет time из стандартной библиотеки который был рассмотрен на прошлом уроке. Внесем небольшие изменения в наш пример:
```
package main

import (
	"fmt"
	"time"
)

func main() {
	go myFunc()
	time.Sleep(1 * time.Second) // Пауза в 1 секунду
}

func myFunc() {
	fmt.Println("hello")
}

// Вывод: hello
```
Теперь все работает. Количество горутин, которые мы можем запустить, не ограничено.

### Анонимные горутины
```
//Самовызывающаяся анонимная горутина
go func() {
 fmt.Println("Привет, я анонимная горутина")
}()
```

Это позволяет писать код, который используется в одном месте и сразу вызвать, не заботясь об объявлении функции

### Функция main()
Удивительно, но функция main() вызывает свою собственную горутину.

По умолчанию используется кол-во ядер вашего процессора. Но мы можем изменить количество используемых ядер простой строчкой кода. Приложению будет дана команда перейти на 4 ядра:

> runtime.GOMAXPROCS(4)

примеры горутин
> https://play.golang.org/p/caWNyYWZ91E

* https://habr.com/ru/post/412715/

### Каналы
Основное преимущество Go заключается в том, что он не просто позволяет выполнять несколько задач параллельно и конкурентно, но позволяет организовать удобную связь между горутинами при выполнении этих задач. Для этой цели используются каналы, по которым как по системе пневматической почты в старых офисах мы можем передавать данные.

Канал представляет собой механизм связи, который позволяет одной горутине отправлять некоторые значения другой горутине. Каждый канал является средством передачи значений определённого типа, который называется типом элементов канала.

Чтобы создать канал используется встроенная функция make:
```
channel := make(chan int)    // channel имеет тип 'chan int'
```

Как и отображение, канал является ссылкой на структуру данных. Копируя или передавая канал в функцию в качестве аргумента, мы копируем ссылку на одну и ту же структуру данных. Нулевым значением канала является nil.

Канал имеет две основные операции:

* Отправление (запись) - передаёт через канал значение из одной горутины в другую.
* Получение (чтение) - получение через канал значения из другой горутины.

Обе операции записываются с использованием оператора <b><-</b>, например:
```
channel <- num    // отправляет в канал channel значение num
num = <- channel  // получение из канала channel в переменную num
```
Чтение из канала может производится в цикле:
```
for v := range channel {
    ...
}
```
В приведенном примере чтение из канала будет осуществляться пока канал channel открыт.

Каналы поддерживают операцию закрытия встроенной функцией close:
> close(channel)
Эта функция устанавливает, что данные с помощью этого канала больше не будут передаваться.

Попытка передать данные в закрытый канал приведет к возникновению аварийной ситуации, однако операция получения будет работать и с закрытым каналом - будут получены все значения, которые были отправлены, но еще не прочитаны. После получения всех значений из канала, будет возвращаться нулевое значение типа канала.

Тип канала - не единственная его характеристика. Каждый канал имеет длину и емкость (их можно получить с помощью знакомых нам функций len() и cap()): длина - количество значений в канале в текущий момент, емкость - размер буфера. Наличие буфера позволяет записать в канал определенное количество значений, не вычитывая их при этом.

При отправлении значения в небуферизованный канал отправляющая горутина блокируется до тех пор, пока другая горутина не выполнит получение из этого канала. После этого обе горутины продолжают работать. Верно и обратное, если горутина получает значение, она блокируется, пока значение не будет получено.

Для того, чтобы разобраться в этом вопросе, рассмотрим следующий пример:
```
c := make(chan int, 1) // здесь 1 - размер буфера
fmt.Println(len(c), cap(c)) // 0 1
c <- 1
fmt.Println(len(c), cap(c)) // 1 1
<-c
```

Если же размер буфера будет 0, то выполнение программы приведет к панике, так как записанное значение одновременно с записью в канал не вычитывается. Но об этом мы расскажем подробнее чуть позже, в настоящее время достаточно знать, что такое буферезированные каналы:
```
pipe := make(chan int)     // небуферизованный канал
pipe := make(chan int, 0)  // небуферизованный канал
pipe := make(chan int, 5)  // буферизованный канал с ёмкостью 5
```
Буферизованные каналы имеют очередь элементов. Размер очереди задается при создании канала:

>channel := make(chan string, 3) // буферизованный канал, который может хранить три строковых значения

Операция отправления в буферизованный канал добавляет элемент в конец очереди:

> channel <- "A"

Операция получения извлекает первый элемент из очереди:

> fmt.Println(<-channel) // "A"

Если канал заполнен, операция отправления блокирует свою горутину, до тех пор, пока другая горутина не освободит место, получив данные из канала.

Выбор между буферизованным и небуферизованным каналом, как и выбор емкости каналов, может влиять на корректность работы программы в целом. Небуферизованные каналы дают более надежные гарантии синхронизации, потому что каждая операция отправления связана с операцией получения. В случае буферизованных каналов, эти операции разделены.

### Блокирование выполнения горутины

В некоторых случаях горутины могут быть заблокированы:

блокирование при записи: горутина, посылающая данные в канал, блокируется, пока другая горутина не прочитает данные из этого канала;
блокирование при чтении: горутина, получающая данные из канала,  может быть заблокирована до момента получения данных из канала.
Подробнее про блокировки мы расскажем в следующем уроке. 

* https://m.habr.com/ru/post/490336/ - Анатомия каналов в Go

## Блокировки
В некоторых случаях горутины могут быть заблокированы. Это нужно для того, чтобы горутины могли синхронизироваться между собой.

### Блокировка при записи
Горутина, посылающая данные в канал, блокируется, покуда другая горутина не прочитает данные из него. Всё просто.

### Блокировка при чтении
Горутина, получающая данные из канала,  может быть заблокирована до момента получения данных в канал. Аналогично блокировке при записи.

Программе нет смысла использовать системные ресуры в простое - это затратно по памяти. Для полного понимания, блокировки горутин можно представить как сделку между двумя людьми: пока покупатель не заплатит - продавец не предоставит товар.

### Select-case
Используя конструкцию ***select-case*** можно избежать блокирующего поведения.
```
package main

import "fmt"

func fibonacci(c, quit chan int) {
	x, y := 0, 1
	for {
		select {
		case c <- x:
			x, y = y, x+y
		case <-quit:
			fmt.Println("quit")
			return
		}
	}
}

func main() {
	c := make(chan int)
	quit := make(chan int)
	go func() {
		for i := 0; i < 10; i++ {
			fmt.Println(<-c)
		}
		quit <- 0
	}()
	fibonacci(c, quit)
}
```
При запуске кода выше, в терминале можно будет увидеть такой вывод, это происходит потому горутина прочитает из канала данные, если только они там есть, в противном случае выполняется блок **quit**:
```
0
1
1
2
3
5
8
13
21
34
quit
```

### Синхронизация горутин с помощью каналов
Каналы предназначены для передачи данных, но могут быть использованы не только для этой цели. В частности каналы используются для синхронизации выполнения горутин. Вернемся к примеру из этого шага и изменим его таким образом, чтобы не использовать пакет time:
```
package main

import (
	"fmt"
)

func main() {
	done := make(chan struct{})
	go myFunc(done)
	<-done
}

func myFunc(done chan struct{}) {
	fmt.Println("hello")
	close(done)
}
```
Разберем приведенный пример. Мы создаем канал done, который будет использован для синхронизации (тип канала не важен, но пустая структура не занимает памяти, поэтому использование такого типа крайне выгодно). myFunc закрывает этот канал после завершения работы. После запуска myFunc мы ждем, что канал done вернет нам какое-то значение. В это время myFunc выполняет свою работу и закрывает канал. Т.к. канал закрыт, а значений в канале нет, то Go делает вывод, что done уже ничего не вернет и ожидать значения из него не нужно - функция main продолжает выполнение.

Любой язык программирования рождает определенные шаблоны разработки, и Go не является исключением, на Go такая программа должна выглядеть так:
```
package main

import (
	"fmt"
)

func main() {
	<-myFunc()
}

func myFunc() <-chan struct{} {
	done := make(chan struct{})
	go func() {
		fmt.Println("hello")
		close(done)
	}()
	return done
}
```
Теперь канал для синхронизации создается самой функцией myFunc(), полезная работа выполняется в отдельной горутине. А еще вы могли обратить внимание, что myFunc возвращает <-chan struct{}. Стрелка слева от ключевого слова chan означает, что возвращаемый канал предназначен только для чтения из него. Аналогичным образом мы можем вернуть из функции или передать в нее в качестве аргумента канал, предназначенный только для записи - chan<- struct{}.

### Синхронизация горутин с помощью sync.WaitGroup

Еще одну возможность по синхронизации горутин представляет использование типа sync.WaitGroup. Этот тип позволяет определить группу горутин, которые должны выполняться вместе как одна группа. И можно установить блокировку, которая приостановит выполнение функции, пока не завершит выполнение вся группа горутин. Например:
```
package main

import (
	"fmt"
	"sync"
	"time"
)

func main() {
	wg := new(sync.WaitGroup)

	for i := 0; i < 5; i++ {
		wg.Add(1) // Увеличиваем счетчик горутин в группе
		go work(i, wg) // Вызываем функцию work в отдельной горутине
	}

	wg.Wait() // ожидаем завершения всех горутин в группе
	fmt.Println("Горутины завершили выполнение")
}

func work(id int, wg *sync.WaitGroup)  {
	defer wg.Done()
	fmt.Printf("Горутина %d начала выполнение \n", id)
	time.Sleep(2 * time.Second)
	fmt.Printf("Горутина %d завершила выполнение \n", id)
}
```
Вначале определяем группу в виде переменной wg sync.WaitGroup.

В цикле запускаем функцию work 5 раз в отдельных горутинах, при этом увеличиваем счетчик горутин в группе с помощью метода Add. Число, которое передается в метод Add определяет значение внутреннего счетчика активных элементов.

Чтобы сигнализировать, что элемент группы завершил свое выполнение, в горутине необходимо вызвать метод Done().

Метод Wait блокирует выполнение функции main до завершения выполнения всех горутин, входящих в группу - его мы вызываем после запуска горутин, чтобы дождаться результата их выполнения. Когда внутренний счетчик активных элементов в группе wg станет равен 0, функция main будет разблокирована и продолжит свое выполнение.
```
Горутина 4 начала выполнение 
Горутина 0 начала выполнение 
Горутина 1 начала выполнение 
Горутина 3 начала выполнение 
Горутина 2 начала выполнение 
Горутина 2 завершила выполнение 
Горутина 0 завершила выполнение 
Горутина 4 завершила выполнение 
Горутина 1 завершила выполнение 
Горутина 3 завершила выполнение 
Горутины завершили выполнение
```

### Мьютексы

Рассмотрим такой пример:
```
package main

import (
	"fmt"
	"sync"
)

func main() {
	var x int
	wg := new(sync.WaitGroup)

	for i := 0; i < 1000; i++ {
		// Запускаем 1000 экземпляров горутины, увеличивающей счетчик на 1
		wg.Add(1)
		go func(wg *sync.WaitGroup) {
			defer wg.Done()
			x++
		}(wg)
	}

	wg.Wait()

	// По идее значение счетчика должно быть 1000, но крайне вероятно, что этого не произойдет
	fmt.Println(x)
}
```
Кажется, что результат выполнения работы этой программы будет 1000, но так почти никогда не будет - попробуйте сами. Почему так? Представим себе что первая горутина получает значение переменной x, а вторая горутина одновременно с этим выполняют такую же операцию. Тогда обе горутины считают, что x = 0, затем производятся расчеты и обе горутины присваивают x значение 1 (0 + 1), в результате работа одной из горутин напрасна.

Чтобы не потерять результаты вычислений мы можем использовать тип sync.Mutex:
```
package main

import (
	"fmt"
	"sync"
)

func main() {
	var x int
	wg := new(sync.WaitGroup)
	mu := new(sync.Mutex)

	for i := 0; i < 1000; i++ {
		// Запускаем 1000 экземпляров горутины, увеличивающей счетчик на 1
		wg.Add(1)
		go func(wg *sync.WaitGroup, mu *sync.Mutex) {
			defer wg.Done()
			mu.Lock()
			x++
			mu.Unlock()
		}(wg, mu)
	}

	wg.Wait()
	fmt.Println(x)
}
```
Мютекс имеет методы Lock и Unlock - причем Lock невозможно выполнить подряд дважды, если между этими вызовами не выполнить Unlock. Соответственно если одна горутина взяла Lock, то другие горутины этой операции выполнить уже не могут и вынуждены ожидать, пока взявшая Lock горутина не выполнит Unlock.

Для интереса решил такую же задачу с помощью каналов:
```
func main() {
	wg := new(sync.WaitGroup)
	// создаем буферизированный канал, чтобы не блокировать основной поток
	chn := make(chan int, 1)
	// передаем начальное значение в канал
	chn <- 0
	for i := 0; i < 1000; i++ {
		// Запускаем 1000 экземпляров горутины, увеличивающей счетчик на 1
		wg.Add(1)
		go func(wg *sync.WaitGroup) {
			defer wg.Done()
			// Забираем значение из канала, инкрементируем его и отправляем обратно в тот же канал
			chn <- <- chn + 1
		}(wg)
	}

	wg.Wait()

	// Достаем конечное значение из канала
	fmt.Println(<-chn)
}
```

### Пакет time и параллелизм
Мы уже прошли пакет time, но есть функции которые связаны с параллелизмом.
Перед тем как перейти к рассмотрению типов Timer и Ticker рассмотрим упрощенные их аналоги: