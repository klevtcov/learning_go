## Конкурентность (Concurrency) и параллелизм (Parallelism)

* https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part2.html

Конкурентность предполагает работу приложения с двумя и более задачами одновременно, когда происходит создание нескольких процессов, выполняющихся независимо друг от друга. Когда мы начинаем говорить о многопоточной разработке, нужно ввести такие понятия, как Concurrency и Parallelism. В мире Go есть выражение «Concurrency is not Parallelism». Суть в том, что Concurrency — это о дизайне, то есть о том, как мы проектируем нашу программу. Parallelism — это просто способ выполнения нашего кода.

Конкурентность предполагает работу приложения с двумя и более задачами одновременно, когда происходит создание нескольких процессов, выполняющихся независимо друг от друга.

Приложения могут иметь дело с большим количеством процессов сразу для достижения желаемого поведения. Допустим, есть простенький интернет-магазин. Посмотрим, какие могут быть одновременно выполняемые задачи. Вот их список:

* Запуск на выполнение баннера с последними предложениями и продуктами cверху страницы.
* Показ количества пользователей на сайте в данный момент.
* Обновление содержимого корзины при выборе продуктов.
* Ведение счётчика времени до следующей распродажи и так далее.

Для интернет-магазина важно, чтобы все эти задачи выполнялись одновременно, ведь нужно удержать пользователей на сайте или в приложении, сделав его максимально привлекательным для них, чтобы они оставили здесь свои деньги. Поэтому можно сделать так, чтобы на простом сайте в фоновом режиме выполнялось множество задач.

## Конкурентное и параллельное выполнение

### Работа с конкурентными приложениями
Допустим, у нас одноядерная система и надо выполнить несколько задач, но есть ограничение: одномоментно может быть выполнена лишь одна задача.

В модели конкурентного выполнения имеет место переключение контекста между задачами: приложение работает с несколькими задачами, но не может выполнять их все вместе, ведь ядро всего одно. Переключение контекста происходит настолько быстро, что создаётся ощущение, что задачи выполняются одновременно.

Фактор параллельного выполнения здесь отсутствует: параллельные процессы не могут выполняться вместе просто потому, что наша система одноядерная.

### Добавим приложению параллелизма
В случае с одноядерной системой у нас были ограничения по ресурсам. Если мы добавим несколько ядер, ресурсов станет больше и приложение сможет одновременно выполнять на разных ядрах множество задач. В верхней части той же картинки показано, как на разных ядрах одновременно и параллельно выполняются две задачи.

Конкурентность и параллелизм — очень похожие понятия, но мне кажется, что разницу вы уже уловили.

Таким образом, увеличивая сложность системы, можно увеличить и сложность решаемых с её помощью задач: работая с Golang, мы можем масштабировать приложение, с лёгкостью переходя от конкурентного исполнения к параллельному. Масштабируемость в Golang — это легко!

con_vs_par.png

## Горутины
Горутины реализуют в Golang обёрточный функционал потоков, а управляются они скорее из среды выполнения Go, нежели из операционной системы.

Среда выполнения Go распределяет или забирает ресурсы памяти у горутин. Горутина во многом похожа на поток тем, что касается выполнения множества задач, но потребляет меньше ресурсов, чем потоки операционной системы. Горутина не имеет полного соответствия с потоками.

Горутины (goroutines) представляют параллельные операции, которые могут выполняться независимо от функции, в которой они запущены. Главная особенность горутин состоит в том, что они могут выполняться параллельно. То есть на многоядерных архитектурах есть возможность выполнять отдельные горутины на отдельных ядрах процессора, тем самым горутины будут выполняться паралелльно, и программа завершится быстрее.
 

В Go независимо запущенная задача называется горутиной. Горутины похожи на корутины (из котлина), процессы или потоки в других языках, хотя у них есть много своих особенностей. Их создание рационально, оно значительно упрощает процесс управления многими конкурентными операциями.

Преимущества горутин:

* Они легковесны.
* Легко и без проблем масштабируют.
* Они — практически потоки.
* Требуют меньше памяти (2KB).
* Предоставляют дополнительную память горутинам во время выполнения.

### Запуск горутины в Golang

Запуск горутины очень прост, достаточно прописать перед функцией ключевое слово "go", например:
```
package main

import "fmt"

func main() {
	go myFunc()
}

func myFunc() {
	fmt.Println("hello")
}
```
Все действительно так просто. Вот только если выполнить эту программу, то мы ничего не увидим. Это связано с тем, что после запуска myFunc в отдельной горутине (на это указывает ключевое слово go), функция main продолжает выполняться и завершается, не дожидавшись завершения выполнения всех прочих горутин, соответственно myFunc просто не успевает завершить выполнение. Go предусматривает несколько способов синхронизации выполнения горутин и мы рассмотри их в этом уроке.

Небольшое отступление. Go очень быстр, а нам требуется увидеть результат выполнения работы, а значит - замедлить нашу программу. Для этого мы будем использовать пакет time из стандартной библиотеки который был рассмотрен на прошлом уроке. Внесем небольшие изменения в наш пример:
```
package main

import (
	"fmt"
	"time"
)

func main() {
	go myFunc()
	time.Sleep(1 * time.Second) // Пауза в 1 секунду
}

func myFunc() {
	fmt.Println("hello")
}

// Вывод: hello
```
Теперь все работает. Количество горутин, которые мы можем запустить, не ограничено.

### Анонимные горутины
```
//Самовызывающаяся анонимная горутина
go func() {
 fmt.Println("Привет, я анонимная горутина")
}()
```

Это позволяет писать код, который используется в одном месте и сразу вызвать, не заботясь об объявлении функции

### Функция main()
Удивительно, но функция main() вызывает свою собственную горутину.

По умолчанию используется кол-во ядер вашего процессора. Но мы можем изменить количество используемых ядер простой строчкой кода. Приложению будет дана команда перейти на 4 ядра:

> runtime.GOMAXPROCS(4)

примеры горутин
> https://play.golang.org/p/caWNyYWZ91E

* https://habr.com/ru/post/412715/

