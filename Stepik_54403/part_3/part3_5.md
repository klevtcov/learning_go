## Работа с файлами
Go предоставляет множество методов для работы с ресурсами операционной системы. Выбор метода зачастую зависит от требующей решения задачи. Раскрыть все возможные методы, во-первых, очень сложно, а, во-вторых, этот урок бы очень сильно затянулся. Как следствие, в этом уроке мы попробуем обозначить основные возможности и пакеты их реализующие, если вы захотите получить больше информации о работе с файлами, то обратитесь к документации самостоятельно. И помните, лучшее изучение это практика, так что экспериментируйте с файлами локально.

###  io (io/ioutil с версии 1.16 не рекомендуется)
Пакет io/ioutil предоставляет скромные, но наиболее востребованные возможности по чтению и записи файлов. Вот практически все содержащиеся в пакете функции:
```
func ReadFile(filename string) ([]byte, error)
func WriteFile(filename string, data []byte, perm os.FileMode) error
```
Из сигнатуры этих функций все должно быть предельно ясно: функции реализуют чтение и запись файла, данные считываются / записываются в формате байтового среза. Единственное, что может быть не так очевидно, это параметр perm типа os.FileMode – это права доступа к файлу в битовом формате, знакомом всем, кто знаком с операционными системами *nix.
Следующая функция, которую мы можем использовать:
```
func ReadAll(r io.Reader) ([]byte, error)
```
Здесь в качестве аргумента передается не имя файла, а объект типа io.Reader, соответственно функция может читать данные из всех объектов, удовлетворяющих указанному интерфейсу: в т.ч. сетевые соединения и буферы:
```
b := bytes.NewReader([]byte("Данные в объекте io.Reader"))
data, err := ioutil.ReadAll(b)
if err != nil {
	// ...
}
fmt.Printf("%s\n", data) // Данные в объекте io.Reader
```
Последняя функция позволяет получить информацию о содержании директории:
```
func ReadDir(dirname string) ([]os.FileInfo, error)
```
Не думаю, что в этом вопросе могут возникнуть какие-то проблемы, поэтому просто приведу ряд примеров:
```
func main() {
    dataForFile := []byte("Тестовая строка, предназначенная для записи в файл")
    file_name := "test_file.txt"

    // Создаем новый файл и записываем в него данные dataForFile
    if err := os.WriteFile(file_name, dataForFile, 0600); err != nil {
            log.Fatal(err)
    }

    // Читаем данные из того же файла
    dataFromFile, err := os.ReadFile(file_name)
    if err != nil {
            log.Fatal(err)
    }

    // Сравниваем исходные данные с записанными в файл и прочитанными из него
    fmt.Printf("dataForFile == dataFromFile: %v\n", bytes.Equal(dataFromFile, dataForFile))

    // Получаем текущую директорию
    currentDir, err := os.Getwd()
    if err != nil {
            log.Fatal(err)
    }
    fmt.Println((currentDir))

    // Изучаем содержимое директории
    filesFromDir, err := os.ReadDir(currentDir)
    if err != nil {
            if err != nil {
                    log.Fatal(err)
            }
    }
    for _, file := range filesFromDir {
            // Проходим по всем найденным файлам и печатаем их имя и размер
            info, _ := file.Info()
            fmt.Printf("|_name: %s, size: %d\n", file.Name(), info.Size())
    }

    // Output:
    // dataForFile == dataFromFile: true
    // /home/<user>/<pwd>
    // |_name: main.go, size: 1491
    // |_name: test.txt, size: 93
    // |_...
}
```

+ https://www.cloudhadoop.com/2018/11/learn-golang-tutorials-file-directory.html#how-to-print-current-working-directory--to-console

### os
Следующий пакет, который мы просто обязаны рассмотреть, это пакет os. Он содержит огромный набор высокоуровневых инструментов для работы с файлами (и не только).

Для начала мы должны отметить, что рассматриваемый пакет сам не предоставляет удобных инструментов для чтения и записи в файл, хотя теоретически чтение и запись возможны. Центром пакета является объект os.File, который реализует ряд интерфейсов, в т.ч. Reader и Writer. Таким образом для удобной работы с данным типом нам может потребоваться что-то еще, например для чтения всего файла может быть использована функция ReadAll из ранее рассмотренного пакета io/ioutil. Для создания рассматриваемого объекта мы можем использовать ряд предлагаемых пакетом функций:
```
func Create(name string) (*File, error) // создание файла с именем name
func Open(name string) (*File, error) // открытие файла с именем name
```
Данный объект имеет ряд методов, позволяющих вернуть имя файла, изменить права доступа или владельца файла. Нас же, прежде всего, будет интересовать метод Close(), который должен быть вызван при закрытии файла, чтобы освободить занятые нашей программой ресурсы операционной системы. Чтобы быть уверенными, что файл будет закрыт, а ресурсы освобождены даже в случае критической непредвиденной ошибки, рекомендуется сразу после проверки, что файл создан / открыт запланировать его закрытие с помощью оператора отложенного вызова defer:
```
f, err := os.Open("fileName")
if err != nil {
	...
}
defer f.Close()
```
С имеющимися методами данного типа вы можете ознакомиться в документации, примеры же работы с этим объектом мы приведем в следующем шаге, когда рассмотрим более удобные способы работы с этим типом.

Переименование и удаление файлов делается через функции Rename и Remove:
```
// создаем файл
os.Create("text.txt")
// переименовываем файл
os.Rename("text.txt", "new_text.txt")
// удаляем файл
os.Remove("new_text.txt")
// кстати, os позволяет работать не только с файлами
// выходим из программы:
os.Exit(0)
```
Так же мы можем получать информацию файлов и сравнивать их:
```
file1, _ := os.Create("text.txt")
file2, _ := os.Create("text.txt")
info1, _ := file1.Stat() // функция Stat возвращает информацию о файле и ошибку
info2, _ := file2.Stat()
fmt.Println(os.SameFile(info1, info2)) // true

// вот что мы можем получить из FileInfo:
// A FileInfo describes a file and is returned by Stat and Lstat.
type FileInfo interface {
	Name() string       // base name of the file
	Size() int64        // length in bytes for regular files; system-dependent for others
	Mode() FileMode     // file mode bits
	ModTime() time.Time // modification time
	IsDir() bool        // abbreviation for Mode().IsDir()
	Sys() interface{}   // underlying data source (can return nil)
}
```
Также существует удобная функция WriteString у файлов которая записывает строки в конце файла. Например, нужно открыть существующий файл с какой-то информацией и записать, не затрагивая старую.
```
file1, _ := os.Create("text.txt")
file1.WriteString("1 строка \n")
file1.WriteString("2 строка \n")
file1.Close()

// внутри файла будет:
// 1 строка 
// 2 строка 
```

