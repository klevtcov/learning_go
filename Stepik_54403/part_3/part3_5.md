## Работа с файлами
Go предоставляет множество методов для работы с ресурсами операционной системы. Выбор метода зачастую зависит от требующей решения задачи. Раскрыть все возможные методы, во-первых, очень сложно, а, во-вторых, этот урок бы очень сильно затянулся. Как следствие, в этом уроке мы попробуем обозначить основные возможности и пакеты их реализующие, если вы захотите получить больше информации о работе с файлами, то обратитесь к документации самостоятельно. И помните, лучшее изучение это практика, так что экспериментируйте с файлами локально.

###  io (io/ioutil с версии 1.16 не рекомендуется)
Пакет io/ioutil предоставляет скромные, но наиболее востребованные возможности по чтению и записи файлов. Вот практически все содержащиеся в пакете функции:
```
func ReadFile(filename string) ([]byte, error)
func WriteFile(filename string, data []byte, perm os.FileMode) error
```
Из сигнатуры этих функций все должно быть предельно ясно: функции реализуют чтение и запись файла, данные считываются / записываются в формате байтового среза. Единственное, что может быть не так очевидно, это параметр perm типа os.FileMode – это права доступа к файлу в битовом формате, знакомом всем, кто знаком с операционными системами *nix.
Следующая функция, которую мы можем использовать:
```
func ReadAll(r io.Reader) ([]byte, error)
```
Здесь в качестве аргумента передается не имя файла, а объект типа io.Reader, соответственно функция может читать данные из всех объектов, удовлетворяющих указанному интерфейсу: в т.ч. сетевые соединения и буферы:
```
b := bytes.NewReader([]byte("Данные в объекте io.Reader"))
data, err := ioutil.ReadAll(b)
if err != nil {
	// ...
}
fmt.Printf("%s\n", data) // Данные в объекте io.Reader
```
Последняя функция позволяет получить информацию о содержании директории:
```
func ReadDir(dirname string) ([]os.FileInfo, error)
```
Не думаю, что в этом вопросе могут возникнуть какие-то проблемы, поэтому просто приведу ряд примеров:
```
func main() {
    dataForFile := []byte("Тестовая строка, предназначенная для записи в файл")
    file_name := "test_file.txt"

    // Создаем новый файл и записываем в него данные dataForFile
    if err := os.WriteFile(file_name, dataForFile, 0600); err != nil {
            log.Fatal(err)
    }

    // Читаем данные из того же файла
    dataFromFile, err := os.ReadFile(file_name)
    if err != nil {
            log.Fatal(err)
    }

    // Сравниваем исходные данные с записанными в файл и прочитанными из него
    fmt.Printf("dataForFile == dataFromFile: %v\n", bytes.Equal(dataFromFile, dataForFile))

    // Получаем текущую директорию
    currentDir, err := os.Getwd()
    if err != nil {
            log.Fatal(err)
    }
    fmt.Println((currentDir))

    // Изучаем содержимое директории
    filesFromDir, err := os.ReadDir(currentDir)
    if err != nil {
            if err != nil {
                    log.Fatal(err)
            }
    }
    for _, file := range filesFromDir {
            // Проходим по всем найденным файлам и печатаем их имя и размер
            info, _ := file.Info()
            fmt.Printf("|_name: %s, size: %d\n", file.Name(), info.Size())
    }

    // Output:
    // dataForFile == dataFromFile: true
    // /home/<user>/<pwd>
    // |_name: main.go, size: 1491
    // |_name: test.txt, size: 93
    // |_...
}
```

+ https://www.cloudhadoop.com/2018/11/learn-golang-tutorials-file-directory.html#how-to-print-current-working-directory--to-console

### os
Следующий пакет, который мы просто обязаны рассмотреть, это пакет os. Он содержит огромный набор высокоуровневых инструментов для работы с файлами (и не только).

Для начала мы должны отметить, что рассматриваемый пакет сам не предоставляет удобных инструментов для чтения и записи в файл, хотя теоретически чтение и запись возможны. Центром пакета является объект os.File, который реализует ряд интерфейсов, в т.ч. Reader и Writer. Таким образом для удобной работы с данным типом нам может потребоваться что-то еще, например для чтения всего файла может быть использована функция ReadAll из ранее рассмотренного пакета io/ioutil. Для создания рассматриваемого объекта мы можем использовать ряд предлагаемых пакетом функций:
```
func Create(name string) (*File, error) // создание файла с именем name
func Open(name string) (*File, error) // открытие файла с именем name
```
Данный объект имеет ряд методов, позволяющих вернуть имя файла, изменить права доступа или владельца файла. Нас же, прежде всего, будет интересовать метод Close(), который должен быть вызван при закрытии файла, чтобы освободить занятые нашей программой ресурсы операционной системы. Чтобы быть уверенными, что файл будет закрыт, а ресурсы освобождены даже в случае критической непредвиденной ошибки, рекомендуется сразу после проверки, что файл создан / открыт запланировать его закрытие с помощью оператора отложенного вызова defer:
```
f, err := os.Open("fileName")
if err != nil {
	...
}
defer f.Close()
```
С имеющимися методами данного типа вы можете ознакомиться в документации, примеры же работы с этим объектом мы приведем в следующем шаге, когда рассмотрим более удобные способы работы с этим типом.

Переименование и удаление файлов делается через функции Rename и Remove:
```
// создаем файл
os.Create("text.txt")
// переименовываем файл
os.Rename("text.txt", "new_text.txt")
// удаляем файл
os.Remove("new_text.txt")
// кстати, os позволяет работать не только с файлами
// выходим из программы:
os.Exit(0)
```
Так же мы можем получать информацию файлов и сравнивать их:
```
file1, _ := os.Create("text.txt")
file2, _ := os.Create("text.txt")
info1, _ := file1.Stat() // функция Stat возвращает информацию о файле и ошибку
info2, _ := file2.Stat()
fmt.Println(os.SameFile(info1, info2)) // true

// вот что мы можем получить из FileInfo:
// A FileInfo describes a file and is returned by Stat and Lstat.
type FileInfo interface {
	Name() string       // base name of the file
	Size() int64        // length in bytes for regular files; system-dependent for others
	Mode() FileMode     // file mode bits
	ModTime() time.Time // modification time
	IsDir() bool        // abbreviation for Mode().IsDir()
	Sys() interface{}   // underlying data source (can return nil)
}
```
Также существует удобная функция WriteString у файлов которая записывает строки в конце файла. Например, нужно открыть существующий файл с какой-то информацией и записать, не затрагивая старую.
```
file1, _ := os.Create("text.txt")
file1.WriteString("1 строка \n")
file1.WriteString("2 строка \n")
file1.Close()

// внутри файла будет:
// 1 строка 
// 2 строка 
```

### bufio
Пакет bufio предоставляет нам ряд инструментов для удобного чтения и записи информации из объектов, удовлетворяющих интерфейсам io.Reader и io.Writer. Нас в этом вопросе прежде всего будут интересовать типы bufio.Reader, bufio.Writer и bufio.Scanner. Но перед тем как перейти к рассмотрению данных типов сделаем одно замечание (мы уже говорили об этом раньше в разделе об интерфейсах): объекты в пакете bufio имеют собственный буфер, позволяющий им реализовать дополнительные методы по сравнению с интерфейсами io.Reader и io.Writer, это необходимо учитывать в работе. Если вы не помните, о чем шла речь, вернитесь ненадолго к приведенному в том разделе примеру.

### bufio.Reader
Данный тип создается с помощью функций:
```
func NewReader(rd io.Reader) *Reader // создает Reader со стандартным буфером 4096 байт
func NewReaderSize(rd io.Reader, size int) *Reader // создает Reader с произвольным буфером
```
Рассмотрим некоторые из методов bufio.Reader и примеры работы:
```
file, err := os.Open("test.txt")
if err != nil {
	...
}
defer file.Close()

rd := bufio.NewReader(file)

buf := make([]byte, 10)
n, err := rd.Read(buf) // читаем в buf 10 байт из ранее открытого файла
if err != nil && err != io.EOF {
	// io.EOF не совсем ошибка - это состояние, указывающее, что файл прочитан до конца
	...
}
fmt.Printf("прочитано %d байт: %s\n", n, buf) // прочитано 10 байт: bufio ...

s, err := rd.ReadString('\n') // читаем данные до разрыва абзаца ('\n')
fmt.Printf("%s\n", s)         // ... здесь будет строка
```
bufio.Reader позволяет читать данные по байтам, рунам, строкам и пр., указывать символ, на котором необходимо прекратить чтение. Когда данные будут прочитаны до конца, метод вернет ошибку io.EOF.

### bufio.Writer
bufio.Writer создан для записи в объекты, удовлетворяющие интерфейсу io.Writer, но предоставляет ряд более высокоуровневых методов, в частности метод WriteString(s string):
```
file, err := os.Create("test.txt")
if err != nil {
	...
}
defer file.Close()

w := bufio.NewWriter(file)
n, err := w.WriteString("Запишем строку")
if err != nil {
	...
}
fmt.Printf("Записано %d байт\n", n) // Записано 27 байт

// bufio.Writer имеет собственный буфер, чтобы быть уверенным, что данные точно записаны,
// вызываем метод Flush()
w.Flush()
```
Как вы уже поняли, создается объект функцией NewWriter(w io.Writer).

### bufio.Scanner
bufio.Scanner создан для построчного чтения данных. Создается он функцией NewScanner(r io.Reader), посмотрим, как работает этот тип:
```
file, err := os.Open("test.txt")
if err != nil {
	panic(err)
}
defer file.Close()

s := bufio.NewScanner(file)

// Я заранее записал в файл 5 цифр, каждую на новой строке
for s.Scan() { // возвращает true, пока файл не будет прочитан до конца
	fmt.Printf("%s\n", s.Text()) // s.Text() содержит данные, считанные на данной итерации
}

// 1
// 2
// 3
// 4
// 5
```
### В каких случаях использовать тот или иной пакет стандартной библиотеки
В качестве небольшого отступления рассмотрим вопрос о целесообразности использования того или иного метода чтения / записи. Если объем данных небольшой, то разумно использовать функции из пакета io/ioutil - они позволяют нам не заботиться о закрытии файла (кроме функции ReadAll, которая в качестве аргумента получает тип io.Reader), кроме того, все данные считываются / записываются за раз. Стоит дополнить, что многие методы io/ioutil это просто удобные обертки (абстракции) под капотом которых тот же os.OpenFile и тд. Поэтому если хочется более близкий доступ к системе и возможностям используйте os.

Но что если объем данных велик, или не все данные используются единовременно (или готовятся к записи постепенно)? Тогда правильно будет отдать предпочтение пакету bufio, который может считывать данные поэтапно, в т.ч. построчно, записывать данные постепенно.

Если же данные предоставлены нам в специальном формате: csv, json, xml и пр., то правильным будет использовать специальные пакеты Go для работы с такими данными. Стандартная библиотека Go позволяет читать и записывать данные в различных структурированных форматах. Далее мы рассмотрим чтение и запись в формате CSV (данные в столбцах разделены символами "," или ";").

+ Ввод строки без секса головного мозга:
```
scanner := bufio.NewScanner(os.Stdin)
scanner.Scan()
s := scanner.Text()
```
+ Вывод строки без секса головного мозга:
> io.WriteString(os.Stdout,"то_что_нужно_вывести_типа_string")