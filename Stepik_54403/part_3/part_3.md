### Отображения, по другому - map, карта, словарь, хеш-таблица, ключ-значение

Отображения - структура данных, неупорядоченная коллекция пар "ключ-значение", в которой все ключи различны, а значение, связанное с заданным ключом, можно получить, обновить или удалить независимо от размера карты (отображения).

Отображение в Go представляет собой ссылку на хеш-таблицу, а его тип записывается как map[K]V, где К и V являются типами его ключей и значений.

Все ключи в данном отображении имеют один и тот же тип, как и все значения имеют один и тот же тип, но тип ключей не обязан совпадать с типом значений. Тип ключа К должен быть сравниваемым с помощью оператора ==, чтобы отображение могло проверить, равен ли данный ключ одному из имеющихся в нем.

### Создание отображений
Объявление map выглядит так:
```
var users map[string]int
// string - ключ, int - значения
```
Но так делать опасно, так мы не инициализировали его и при добавлении значений будут ошибки. (см. ниже)
Поэтому есть 2 более правильных способа создания отображений в Go:
```
// с помощью встроенной функции make:
m1 := make(map[int]int)

// с помощью использования литерала отображения:
m2 := map[int]int{
    // Пары ключ:значение указываются при необходимости
    12: 2,
    1:  5,
}

fmt.Println(m1) // map[]
fmt.Println(m2) // map[1:5 12:2]
```
Отображение в Go - ссылка на хэш-таблицу, а нулевое значение ссылки nil. Попытавшись в дальнейшем добавить значение для определенного ключа мы получим ошибку "assignment to entry in nil map", которая приведет к панике:
```
var m map[int]int
m[12] = 3
fmt.Println(m)

// Вывод (сработает паника):
// panic: assignment to entry in nil map
```
Конечно же мы можем использовать такое объявление когда нам не нужно вручную добавлять элементы, например просто присвоить результату из функции, но нужно быть крайне осторожным в таких случаях.
```
var m map[int]int
m = someFunc()
fmt.Println(m)
// Второй вариант безопаснее
var m = map[int]int{}
m = someFunc()
fmt.Println(m)
```

### Работа с отображениями

* Обратиться к элементам отображения можно с помощью обычной индексации:
```
m := map[int]int{
	12: 2,
	1:  5,
}
fmt.Println(m[12]) // 2
```
* Удаление осуществляется с помощью встроенной функции delete:
```
m := map[int]int{
	12: 2,
	1:  5,
}
delete(m, 12) // Удаление элемента по ключу 12
fmt.Println(m) // map[1:5]
```
Все эти операции безопасны, даже если элемент в отображении отсутствует: при использовании ключа, которого нет в отображении, поиск возвращает нулевое значение соответствующего типа:
```
m := make(map[int]int)

fmt.Println(m[12]) // 0

delete(m, 12)
fmt.Println(m) // map[]
```
В приведенном примере мы видим, что если ключ в отображении отсутствует, то при обращении к значению по ключу будет возвращено нулевое значение соответствующего типа. Особенно это критично, если согласно логике нашей программы такое нулевое значение может иметь место. Как же понять, что ключ в отображении присутствует? Мы можем воспользоваться тестом из следующего примера:
```
m := map[int]int{
	1: 10,
}

if value, inMap := m[1]; inMap {
	fmt.Println(value) // 10
}

if value, inMap := m[2]; inMap {
	fmt.Println(value) // Условие не выполняется
}
```
Второе значение inMap - это логическое значение, показывающее, имеется ли данный элемент в отображении. Этой логической переменной часто дают имя ok.

Для перечисления всех пар "ключ-значение" в отображении мы используем циклы по диапазону, аналогичные тем, которые мы использовали для массивов и срезов. Последовательные итерации приведенного ниже цикла присваивают переменным key и value значения из очередной пары "ключ-значение" :
```
for key, value := range mapName {
    fmt.Println(key, value)
}
```
Кроме того, Go позволяет применить к отображению функцию len, которая вернет количество пар "ключ-значение", хранящееся в отображении:
```
m := map[int]int{
	1: 10,
	2: 20,
	3: 30,
}
fmt.Println(len(m)) // 3
```


