### Интерфейсы

Интерфейс представляет из себя контракт, определяющий методы, которым обязан обладать объект, удовлетворяющий интерфейсу. Не очень понятно? Попробуем раскрыть эту тему таким образом, чтобы не просто разобраться с понятием интерфейса, но и научиться применять эти знания на практике.

+ https://www.digitalocean.com/community/tutorials/defining-methods-in-go-ru#%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81%D1%8B

+ https://habr.com/ru/company/mailru/blog/463063/ 

### Объявление интерфейса

Интерфейсы, как и другие типы в Go, объявляются с помощью ключевого слова type, за которым следует имя объявляемого типа, а за ним - базовый тип (в нашем случае - interface). В фигурных скобках указаны имена и описания методов, которые должен иметь объект, чтобы "удовлетворять" данному интерфейсу. Реализация методов может быть совершенно разной, важно само наличие метода с соответствующим описанием (принимаемые аргументы и возвращаемые значения).

Посмотрим как объявляется интерфейс на примере пакета io стандартной библиотеки:
```
type Reader interface {
	Read(p []byte) (n int, err error)
}

type Writer interface {
	Write(p []byte) (n int, err error)
}
```
Объекты, удовлетворяющие интерфейсу io.Reader, имеют метод Read, который получает срез байт (буфер, в который производится чтение) в качестве аргумента, а возвращает количество прочитанных байт и сообщение об ошибке. Интерфейс io.Writer делает все наоборот: его метод Write получает срез байт (буфер, из которого производится чтение), возвращает количество записанных байт и сообщение об ошибке.

Ничего большего интерфейс не определяет. Тип реализует интерфейс путем реализации всех его методов.

### Использование интерфейса
Решим реальную задачу с использованием интерфейсов, а параллельно ответим на вопрос в комментариях к задаче в рамках этого курса. Часть кода в примерах будет опущена. Итак, проблема в задаче возникла в чтении 2х строк с использованием пакета bufio, вот 2 решения:
```
var str1, str2 string

/*
 * Данное решение работало на локальной машине,
 * но на платформе Stepik вторая строка считывалась пустой
 */
str1, _ = bufio.NewReader(os.Stdin).ReadString('\n')
str2, _ = bufio.NewReader(os.Stdin).ReadString('\n')

/*
 * Данное решение работало и на локальной машине и на платформе
 * Stepik. Разница в том, что в первом решении объект bufio.Reader
 * создается дважды.
 */
r := bufio.NewReader(os.Stdin)
str1, _ = r.ReadString('\n')
str2, _ = r.ReadString('\n')
```
Функция bufio.NewReader принимает в качестве аргумента как раз интерфейс io.Reader, в примере в качестве аргумента передается os.Stdin - стандартный ввод (файл). Это значит, что мы можем передать данной функции в качестве аргумента что-то иное, что можем контролировать лучше, чем стандартный ввод пользователя с клавиатуры. Используем буфер из пакета bytes, который удовлетворяет интерфейсам io.Reader и io.Writer:
```
// Объявление переменных str1, str2 опущено

func fn1() {
	buf := bytes.NewBufferString("string1\nstring2\n")
	fmt.Printf("Размер буфера до чтения первой строки: %d\n", buf.Len()) // Размер буфера до чтения первой строки: 16

	str1, _ = bufio.NewReader(buf).ReadString('\n')
	fmt.Printf("Размер буфера после чтения первой строки: %d\n", buf.Len()) // Размер буфера после чтения первой строки: 0
	str2, _ = bufio.NewReader(buf).ReadString('\n')

	fmt.Println(str1, str2) // string1
}

func fn2() {
	buf := bytes.NewBufferString("string1\nstring2\n")
	fmt.Printf("Размер буфера до чтения первой строки: %d\n", buf.Len()) // Размер буфера до чтения первой строки: 16

	r := bufio.NewReader(buf)
	str1, _ = r.ReadString('\n')
	fmt.Printf("Размер буфера после чтения первой строки: %d\n", buf.Len()) // Размер буфера после чтения первой строки: 0
	fmt.Printf("Размер буфера bufio.Reader: %d\n", r.Buffered()) // Размер буфера bufio.Reader: 8
	str2, _ = r.ReadString('\n')

	fmt.Println(str1, str2) // string1 ... string2
}
```
Дебагер и чтение кода помогли в дальнейшем разобраться с происходящим, но все началось с тестирования, когда вместо чтения со стандартного ввода мы использовали другой объект, реализующий тот же интерфейс. Если кто-то не понял, как и что произошло в разборе: bufio.Reader имеет свой буфер, в который читает байты из переданного ему io.Reader. Поэтому когда в первом случае мы использовали два bufio.Reader, второй ничего уже прочитать не мог - все было сохранено в буфере первого bufio.Reader.

Если продолжить разговор об интерфейсах io.Reader и io.Writer мы увидим, что эти интерфейсы реализуют: буферы, файлы, сетевые соединения, кодеры и декодеры и пр. Написав один раз функцию для чтения или записи мы, в конечном итоге, сможем использовать ее в десятках различных ситуаций: прочитать не из командной строки, а из сетевого соединения, а записать не на стандартный вывод, а в базу данных.

### Пустой интерфейс
Интерфейс, который не содержит ни одного метода называется пустым интерфейсом: interface{}. Пустой интерфейс может содержать значение любого типа. Пустые интерфейсы используются в коде, где необходимо работать со значениями неизвестного типа. Например, fmt.Print() принимает любое количество аргументов типа interface{}.

### Встраивание интерфейса
Стиль программирования на Go предполагает, что чем более четко мы сформулируем задачу, тем меньше вероятность возникновения ошибки. Таким образом (я продолжу использовать для примера интерфейсы из пакета io), если мы хотим использовать функцию лишь для чтения данных, то разумно использовать в качестве аргумента интерфейс io.Reader, а если для записи, то io.Writer.

Вместе с тем, Go позволяет нам совмещать интерфейсы, чтобы показать, что объект должен удовлетворять обоим интерфейсам. Это реализуется через создание нового интерфейса, в который требуемые нам интерфейсы встраиваются:
```
type ReadWriter interface {
    Reader  // это io.Reader
    Writer  // это io.Writer
}
```
Таким образом Go будет проверять, что у объекта есть методы обязательные для обоих интерфейсов: Read и Write.

Обратите внимание на используемые имена интерфейсов: в Go считается правильным называть интерфейс через имя его методов с добавлением суффикса -er, а если таких методов несколько, использовать имена всех методов.

### Приведение типа
Приведение типа позволяет нам получить внутреннее значение интерфейса, в полной мере это реализуется следующим образом:
```
// Конструкция приведения типа:
// t, ok := i.(T)

// Пример:
var i interface{} = 12

if v, ok := i.(int); ok {
	fmt.Println(v+12) // Суммирование не произойдет, если ok == false
}
```
Здесь t значение, приведенное к типу T, а i - исходное значение интерфейсного типа. ok - логическое значение, показывающее успешность приведения типа: true - все удачно, false - использование t приведет к панике. Значение ok может быть опущено, но будьте аккуратны с этим.

Но что делать, если мы не знаем типа объекта, лежащего внутри интерфейса? Тогда мы можем воспользоваться конструкцией, называемой переключателем типов, выглядит она следующим образом:
```
switch v := i.(type) {
	case T1:
		...
	case T2, T3:
		...
	default:
		...
}
```
Возьмем теперь такой пример:
```
package main
import "fmt"
func do(i interface{}) {
	switch v := i.(type) {
	case int:
		fmt.Println("Умножим на 2:", v*2)
	case string:
		fmt.Println(v + " golang")
	default:
		fmt.Printf("Я не знаю такого типа %T!\n", v)
	}
}

func main() {
	do(21)
	do("hello")
	do(true)
}
```
Вывод будет таким:
```
Умножим на 2: 42
hello golang
Я не знаю такого типа bool!
```

+ https://golang-blog.blogspot.com/2019/06/go-specification-type-switch.html

### Интерфейс error
В Go довольно много интерфейсов, применяемых повсеместно. Безусловно, наиболее распространенный среди них, это интерфейс error:
```
type error interface {
    Error() string
}
```
Это знание позволяет нам создавать свои собственные типы ошибок, хранящие требуемые нам сведения о возникшей проблеме. Если же нам достаточно базовой реализации стандартной библиотеки, мы можем использовать пакеты errors или fmt.

+ Типы ошибок. Создание собственного типа ошибки
В ряде случаев нам может быть не достаточно информации об ошибке в виде строки, и мы хотим добавить в нее какой-то контекст. В этом случае мы можем создать собственный тип, удовлетворяющий интерфейсу error. Допустим функция получает в качестве аргумента строку, которая не должна содержать цифр, а если это не так мы должны прервать обработку и вернуть в качестве контекста позицию в строке, на которой обнаружена цифра:
```
package main

import (
	"fmt"
	"unicode"
)

type customError uint

func (c customError) Error() string {
	return fmt.Sprintf("цифра, индекс %d", c)
}

func errorInString(str string) error {
	// Полезная работа со строкой проигнорирована
	for i, s := range str {
		if unicode.IsDigit(s) {
			return customError(i)
		}
	}
	return nil
}

func main() {
	err := errorInString("string1string")
	if err != nil {
		fmt.Printf("Ошибка обработана: %v\n", err)
	}
	if cError, ok := err.(customError); ok {
		fmt.Printf("Контекст: %d\n", cError)
	}

	// Output:
	// Ошибка обработана: цифра, индекс 6
	// Контекст: 6
}
```
В примере мы создали свой тип ошибки, вернули его, привели его тип из интерфейса и получили требуемый нам контекст. Изучая стандартную библиотеку вы найдете примеры таких специальных ошибок. Для примера ошибка EOF из пакета io (EndOfFile). Но только что продемонстрированный способ обработки ошибок был принят в Go до версии 1.13, в настоящее время стандартная библиотека Go предоставляет более серьезные возможности для работы с ошибками.

### Интерфейс Stringer
В заключение рассмотрим еще один распространенный интерфейс стандартной библиотеки fmt.Stringer:
```
type Stringer interface {
	String() string
}
```
Функция String возвращает текстовое представление объекта: функции из пакета fmt проверяют, удовлетворяет ли переданный функции аргумент интерфейсу Stringer, и если удовлетворяет - он выводится на печать в заданном формате. Посмотрим пример из пакета fmt:
```
type Animal struct {
	Name string
	Age  uint
}

func (a Animal) String() string {
	return fmt.Sprintf("%v (%d)", a.Name, a.Age)
}

func ExampleStringer() {
	a := Animal{
		Name: "Gopher",
		Age:  2,
	}
	fmt.Println(a)

	// Output: Gopher (2)
}
```